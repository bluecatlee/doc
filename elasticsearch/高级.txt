分布式搜索

	文档版本控制?
	es中使用了乐观锁(版本号)来控制并发冲突
	文档有_version字段 每次修改都会递增
	内部版本控制机制：每次操作请求 只有版本号一致时才会成功
	外部版本控制机制：外部文档版本比内部文档版本高时才能更新成功。  主要用于多节点间的数据同步

	#####################################################################################################################################################################
	路由?
	shard = hash(routing) % numbeer_of_shards
	routing路由键可以是任意字符串 默认是文档id。 所有数据在所有分片上大致是均匀分布的
	可以为文档指定多个路由值
	
	默认es由某个节点接收到查询请求后会广播到该索引的所有分片上 每个分片处理完之后由通道节点合并排序后最终返回。而使用确定的路由值可以直接确定到分片的位置 减少资源性能开销
	主分片的数量在创建索引时就确定了 并且不能改变 因为分片数改变了 原先的路由值将会无效 导致文档丢失

	#####################################################################################################################################################################
	数据在多个分片上怎么搜索？
	
		步骤
			1. Scatter:  es客户端向所有分片发起搜索请求
			2. Gather:   每个分片独立完成搜索 将符合条件的结果全部返回
			3. 客户端将结果重新排序和排名 最终返回结果
		
		问题：
			1.数量问题。 所有分片都会返回符合条件的用户要求的size条数据 最终可能会返回分片数shards*size条数据
			2.排名问题
			
		解决方案：
			搜索类型
				query and fetch 	每个分片返回数据document和计算后的排名 速度最快 但是数量可能是用户需求size的shards倍 已废弃
				query then fetch	第一次查所有分片 只获取排序 排名信息(不包含文档数据) es客户端重新排序和排名后 再去分片精确查找对应的数据 数据量是正确的
				DFS query and fetch  第一步多了初始化散发(initial scatter)步骤 可以更精确控制搜索打分和排名
				DFS query then fetch 第一步多了初始化散发(initial scatter)步骤
				SCAN				扫描 不排序 已废弃
				COUNT				计数 已废弃
				
				扩展DFS:
					在真正的查询之前 把各分片的词频率和文档频率收集
					搜索时按照全局的词频率和文档频率进行搜索和排名(每个分片的同一个词的词频率和文档频率是不一样的)
					效率会变低 因为可能会请求三次分片 但是搜索精度是最高的
		
		
	#####################################################################################################################################################################
	如何分页？多分片分页，相当于传统关系型数据库的多库分页
		方案一：普通分页 from size
		普通分页是获取前n条所有数据 排序后 再取from开始的size条数据的。在多分片情况下 需要搜索shards*(from+size)条数据 而且每次都要重新排序。性能差 容易OOM
		es为了避免深分页 不允许使用分页from size来查询10000条以后的数据。此时需要使用scroll(游标)来查询
		index.max_result_window:10000 可以修改 但不建议
		
		方案二：scroll游标
		scroll 类似关系型数据库的cursor 利用了缓存 只需要搜索一次 排序一次。但不适合实时搜索。
		
		步骤
			1.初始化 将所有符合条件的数据缓存(相当于快照) 
			2.对缓存中的数据进行遍历(对缓存数据修改 不影响原数据 但是实时性会降低)
			
			(如请求参数scroll=1m设置缓存1分钟，返回scroll_id可以作为下次请求的参数使用，即可从该缓存继续获取数据，
			但是每次使用scroll_id时需要刷新scroll的时间 不然可能会造成数据不一致)
			
		方案三:	
		search_after 	
			类似scroll。 search_after提供了一个活的游标来拉取从上次返回的最后一个请求开始拉取下一页的数据
			但是搜索的时候至少使用一个唯一的字段进行排序(建议使用_uid)
			返回的排序值可以用于search_after参数以便抓取下一页的数据
			
			说明：使用search_after参数的时候 from必须设置为-1或0或者不设置
			
			无状态的 实现了实时性 但是不能随机跳转到任意的分页 (scroll是有状态的)
			
	#####################################################################################################################################################################		
	某个词在单个文档里怎么表示？即怎么表示单个文档里的所有词？
		倒排索引优势在于查找包含某个词的文档。
		Doc Values
			默认开启。如果确定不会对某个字段进行聚合、排序或执行脚本,可以关闭。
			默认对所有除了分词的字段起作用。
			Doc Values在创建倒排索引的时候也会创建 像倒排索引一样基于per-segment，且是不可变，被序列化存储到磁盘。
			利用操作系统的文件缓存来代替JVM的heap(堆) 
		
	#####################################################################################################################################################################	
	排序？
		默认按照得分score排序 同分时根据sort排序
		每次查询都是重新查询 score同分时如果没有其他排序规则会造成同分数据无序。
		可以设置按字段排序sort 但是按字段排序会导致score失效 此时可以设置track_scores为true
			
			