灵魂拷问
	锁的到底是什么？
		答：行锁锁的是索引。
	
		对于非主键索引，在索引记录上加锁之后，会再去主键索引上加锁。
		如果表上没有索引，会在隐藏的主键索引上加锁。
		如果要锁的列没有索引，进行全表记录加锁，即变为表锁。
		列上有索引，但是大批量更新，mysql认为大量使用行锁效率低，也可能会将行锁升级为表锁。
		
	锁是干啥的？
		比如行锁，为了避免脏读，就需要行锁，当某一行记录被锁定，其他要修改该行数据的事务就必须阻塞，知道获取到行锁。
		当然，表锁也可以，只不过表锁并发性能太差。
	
	自增主键的作用？
		答：innodb索引时B+树，插入连续的值的时候 每次都是插入到最后面，可以有效的减少索引页的分裂和数据的移动
			将主键定义为自增唯一的，就能让插入连续。
			不仅仅是唯一标识行的目的，因为就算没有主键，还会有rowid来标识行。
			自增主键的核心是自增和唯一
			
		优缺点？

-----------------------------------------------------------------------------------------------------------------------------------------------
自增锁
	AUTO_INC LOCK
	
	AUTO_INCREMENT值是自增的 唯一的 但不是绝对连续的 大致连续
	自增列的值也不要去更新 否则导致值与AUTO_INCREMENT值不匹配甚至冲突
	
	AUTO_INCREMENT值的自增操作是独立的，不在insert语句的事务中。自增锁不是事务锁。
	所以表描述信息的AUTO_INCREMENT值从1开始，表示下一条插入数据的主键值。
	自增值在mysql8之前是保存在内存中的，没有持久化，重启mysql都会去找自增值的最大值max(id)，然后将max(id)+1 作为这个表当前的自增值。
	mysql8之后有了自增值持久化的能力，就是将自增值的变更记录保存在了redo log中。
	
	auto_increment_offset表示自增起始数字
	auto_increment_increment表示调动幅度
	双写的时候可以配置两个库一个写入奇数，一个写入偶数，避免主键冲突
	select last_insert_id(); 获取最后一个插入的数字
	truncate会清空AUTO_INCREMENT值
	
	插入模式
		simple insert 插入的记录行数是确定的，如insert into t(name) values('test')
　　　　bulk insert 插入的记录行数不能马上确定的，如load data | insert into ... select .... from ....
　　　　mixed insert 这些都是simple-insert，但是部分auto increment值给定或者不给定。
					 如insert into t(id,name) values(1,'a'),(null,'b'),(5,'c'); INSERT ...ON DUPLICATE KEY UPDATE.
	
	如果存在自增字段， mysql就会维护一个自增锁。
	自增锁模式innodb_autoinc_lock_mode   （show variables like '%innodb_autoinc_lock_mode%';）
		0：traditonal传统模式。是5.1版本之前的默认值。
			每次都会产生一个锁，类似于表锁（语句级的表级的auto_inc锁），数据插入之后(不管是否成功)才释放锁，是影响并发插入性能的因素之一。
			流程：先申请AUTO_INC锁，得到AUTO_INCREMENT值n并自增，执行插入操作，将n写入到新增的对应字段中(一般是id), 释放AUTO_INC锁。
			能保证主键连续
		
		1：consecutive连续模式。 默认值。产生一个轻量锁
				  对simple insert做了优化。simple insert一次性插入的个数可以立马确定，所以可以一次性生成几个连续的自增值，
				  而且获取到自增值之后锁就可以释放
				  如果是bulk insert 还是会获取表级的AUTO_LOCK锁。因为bulk insert不能立即确定插入的记录数。
				  不保证主键连续
		
		2：interleaved交错模式。mysql8之后的默认值。不会锁表，来一个处理一个，并发度最高。SBR不安全。
						这个模式会影响数据导入
		
		
	【INSERT ...ON DUPLICATE KEY UPDATE的一个问题】
		在实际操作为update的时候，也会自增AUTO_INCREMENT值，实际会使得id自增的非常快。容易超出字段类型的最大值。
		解决：方案一：先查询，再更新。但是可能违背了最开始使用这个方式的初衷，尤其是用这种方式生成sequence id的时候，还影响并发性能。
			  方案二：修改自增锁模式为交错模式 这种方式有弊端

-----------------------------------------------------------------------------------------------------------------------------------------------			  
表锁
	自动加锁。对于myisam，查询操作（SELECT），会自动给涉及的所有表加读锁，更新操作（UPDATE、DELETE、INSERT），会自动给涉及的表加写锁。
			  也可以显示加锁：
					共享读锁：lock table tableName read;
					独占写锁：lock table tableName write;
			  批量解锁：unlock tables;
	对于myisam，写锁的优先级高于读锁，写操作太多会阻塞读操作。
	
	注意：表锁和表级锁不是一个概念
		  表级锁包括表锁
		  此外还有元数据锁MDL(Meta Data Lock)，当对一个表做增删改查操作的时候，加MDL读锁；当要对表做结构变更操作的时候，加MDL写锁
	
-----------------------------------------------------------------------------------------------------------------------------------------------	
行锁	
	两阶段锁协议
		在InnoDB事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。

	自动加锁。对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加排他锁；
			  对于普通SELECT语句，InnoDB不会加任何锁；当然我们也可以显示的加锁：
					共享锁：select * from tableName where ... + lock in share more
					排他锁：select * from tableName where ... + for update


	记录锁
		Record Lock
		
		对主键索引或唯一索引，如果where条件全部命中，不会加Gap锁，只会加记录锁。
		当使用唯一索引来搜索唯一行的语句时，不需要间隙锁定。
		
		select * from t where i = 10;              // 不会加锁，因为普通查询是快照读
		select * from t where i = 10 for update;   // id有唯一索引，此时会使用记录锁
		select * from t where i = 10 for update;   // id没有唯一索引或者id没有索引，此时会使用间隙锁
		
	间隙锁
		Gap Lock
		
		对主键索引或唯一索引，where条件部分命中或者全不命中，会加Gap锁
		Gap锁不是互斥的
		
		比如操作一个区间的数据，会锁住这个区间的所有数据(左开右闭)，即使这个记录不存在。此时另一个会话往这个区间插入数据，就必须等待上一个操作完成。
		“间隙”就是在条件范围内但是实际不存在的数据
		
		缺点：
			造成某些不存在的键值也会被锁定，造成无法插入锁定值范围内的任何数据
			
		【间隙锁就是innodb在可重复读提交下为了解决幻读问题引入的】	
			RR可重复读隔离级别下是有幻读的问题的，即多次查询会查询出其他事务新增或删除的记录，如果对范围进行加锁(间隙锁)，就不会有这个问题。
			
		其他：间隙锁会阻塞插入意向锁。
			  两个事务在同一个间隙上加锁(间隙锁相互兼容，不会阻塞)，都在这个间隙内插入数据，
			  会导致相互等待间隙锁(因为要获取插入意向锁)，造成死锁。

	临键锁
		Next-key Lock
		记录锁和间隙锁结合，可以理解为一种特殊的间隙锁。
		
		RR级别对行的扫描锁定默认都是这个锁。如果查询中包含唯一索引且条件命中，就会只适用记录锁。

--------------------------------------------------------------------------------------------------------------------------------------------------		
页锁
	介于表锁和行锁之间
		

--------------------------------------------------------------------------------------------------------------------------------------------------		
意向锁
	为了让表锁和行锁共存，避免为了判断是否有行锁而进行全表扫描，所以是innodb引擎才会有
	意向锁是表级锁，自动加的。有意向锁就说明表中有数据行被锁定了。
	
	1.意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的 IS 锁。
	2.意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的 IX 锁。
	意向锁协议(intention locking protocol)并不复杂：
		事务要获得某些行的S锁，必须先获得表的IS锁
		事务要获得某些行的X锁，必须先获得表的IX锁
	意向锁之间本身是相互兼容的，意向锁与普通读锁/写锁之间 只有意向写锁和写锁兼容，其余都互斥
	
	3.插入意向锁（Insert Intention Locks）
		本质也可以看成一个间隙锁，是专门针对insert的
		多个事务，在同一个索引，同一个范围区间插入记录时，如果插入的位置不冲突，不会阻塞彼此
		主要是提高并发插入性能的，相比单纯的强互斥写锁性能好点。修改删除都要加强互斥写锁。

--------------------------------------------------------------------------------------------------------------------------------------------------
死锁
	一般来说表锁不会发生死锁，因为表锁是一次性全部获取到的

	以固定的顺序访问表和行。交叉访问更容易造成事务等待回路。
	尽量避免大事务，占有的资源锁越多，越容易出现死锁。建议拆成小事务。
	降低隔离级别。如果业务允许，将隔离级别调低也是较好的选择，比如将隔离级别从 RR 调整为 RC，可以避免掉很多因为 gap 锁造成的死锁。
	为表添加合理的索引。防止没有索引出现表锁，出现死锁的概率会突增。

	innodb能检测死锁并进行恢复 是针对行锁的。对于表锁死锁无法检测恢复
	
	基本原则
		多个锁时按顺序获取锁
		表锁这种可以一次性全部获取
		锁中不要进行长时间操作
		对于有写操作的情况，可以直接获取排它锁 不用先获取共享锁
		
	 SHOW INNODB STATUS; 查看锁	

--------------------------------------------------------------------------------------------------------------------------------------------------
MVCC		
	多版本并发控制。
	使用了行级锁row_level_lock，与innodb的innodb_row_lock有区别
	
	每行数据都有一个版本，每次更新时会更新版本号
	修改时copy出新的快照进行修改，事务之间相互不影响
	保存时比较版本号，版本号不一致则回滚并放弃当前快照
	
	InnoDB通过undo log保存每条数据的多个版本，多个版本之间用链表连接，并且能够找回数据历史版本提供给用户读，每个事务读到的数据版本可能是不一样的。
	在同一个事务中，用户只能看到该事务创建快照之前已经提交的修改和该事务本身做的修改。
	
	innodb中，每一行记录默认会加三个字段
		DB_TRX_ID 		最近一次对该行记录新增/修改的事务id
		DB_ROLL_PTR 	回滚指针，记录当前记录的undo log
		DB_ROW_ID		行id，主要是如果没有主键或非空唯一列时用来生成聚簇索引的
	
	也是一种乐观锁的实现，类似于下面的逻辑，实际不是：
	（innodb中 每一行记录的后面会增加两个隐藏列：创建版本号create_version和删除版本号delete_version
	  insert数据时，commit成功后，create_version值为当前事务id（系统版本号分配）
	  update数据时，commit成功后，原纪录会删除，即delete_version值设置为当前事务id，并重新插入一条数据
	  delete数据时，commit成功后，就把事务id作为删除版本号
	  query：事务id为2的事务只能读取到create version<=2，delete_version > 2或为空的已提交的事务的数据集）
	
	
	两种读的方式
		快照读：简单的select不加锁，是快照读。【这里的快照底层叫Read View】
				mysql实现可重复读就是使用MVCC机制读取undo中已提交的数据，且是非阻塞的读(因为没有磁盘I/O)
				RR下快照读的建立时机不是begin开启事务的时候，而是第一次select的时候。同一个事务内以后的select都会读取这个快照。
				RC下每次快照读都会重新读取最新数据并建立新的快照，所以会出现不可重复读的问题。
		
		
		当前读：需要加锁的语句都是当前读
				 insert、 update、 delete、 select .. for update
				 
	
	MVCC手段只适用于Msyql隔离级别中的读已提交（Read committed）和可重复读（Repeatable Read）。MVCC主要作用于事务性的，有行锁控制的数据库模型
	读未提交不适合用MVCC，因为MVCC的版本号需要提交后才产生，
	串行化不适合用MVCC，因为是会对所涉及到的表加锁，并非行锁，自然也就不存在行的版本控制问题
	
	Mysql的MVCC不是严格的MVCC，因为写本身是排他的。只是利用它做了非阻塞读(可以读快照)。