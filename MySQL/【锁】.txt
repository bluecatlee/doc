灵魂拷问
	锁的到底是什么？
	答：锁的是索引。
	
	对于非主键索引，在索引记录上加锁之后，会再去主键索引上加锁。
	如果表上没有索引，会在隐藏的主键索引上加锁。
	如果要锁的列没有索引，进行全表记录加锁，即退化为表锁。


行锁	
	记录锁
		Record Lock
		
		对主键索引或唯一索引，如果where条件全部命中，不会加Gap锁，只会加记录锁。
		当使用唯一索引来搜索唯一行的语句时，不需要间隙锁定。
		
		select * from t where i = 10;              // 不会加锁，因为普通查询是快照读
		select * from t where i = 10 for update;   // id有唯一索引，此时会使用记录锁
		select * from t where i = 10 for update;   // id没有唯一索引或者id没有索引，此时会使用间隙锁
		
	间隙锁
		Gap Lock
		
		对主键索引或唯一索引，where条件部分命中或者全不命中，会加Gap锁
		Gap锁不是互斥的
		
		比如操作一个区间的数据，会锁住这个区间的所有数据(左开右闭)，即使这个记录不存在。此时另一个会话往这个区间插入数据，就必须等待上一个操作完成。
		“间隙”就是在条件范围内但是实际不存在的数据
		
		缺点：
			造成某些不存在的键值也会被锁定，造成无法插入锁定值范围内的任何数据
			
		【间隙锁就是innodb在可重复读提交下为了解决幻读问题引入的】	
			RR可重复读隔离级别下是有幻读的问题的，即多次查询会查询出其他事务新增或删除的记录，如果对范围进行加锁(间隙锁)，就不会有这个问题。

	临键锁
		Next-key Lock
		记录锁和间隙锁结合，可以理解为一种特殊的间隙锁。
		
		RR级别对行的扫描锁定默认都是这个锁。如果查询中包含唯一索引且条件命中，就会只适用记录锁。
		
		
		
		
意向锁



MVCC		