show [session|global] status like 'xx' ;

show pocesslist;	查看当前进行的线程

查看慢查询日志


##############################################################
explain 执行计划

	select_type查询类型
		SIMPLE			简单表(不使用表连接或子查询)
		PRIMARY			主查询(外层的查询)
		UNION(UNION		第二个或后面的查询语句)
		SUBQUERY		子查询(子查询中的第一个select语句)
		DERIVED
		
	table：表示输出结果集的表
	
	type：访问类型
		ALL				全表扫描
		index			索引全扫描
		index_merge		索引合并优化
		range			索引范围扫描	常见于< <= > >= between等，且字段建立了索引
		ref				使用非唯一索引扫描或唯一索引的前缀扫描
		ref_or_null		比ref多了条件中包含对null的查询
		eq_ref			使用唯一索引 一般就是关联查询使用主键或者唯一索引
		const,system	使用主键或唯一索引查询，最多只有一个匹配行
		unique_subquery	in的后面是一个查询主键字段的子查询
		index_subquery  in的后面呢是查询非唯一索引字段的子查询
		NULL			不用访问表或者索引
		
	possible_keys:	表示查询中可能使用的索引
	key:	        表示实际使用的索引
	key_len:		表示使用到索引字段的长度
	rows:			扫描行的数量
	Extra：			执行情况的说明和描述，如using where或using index
					using where说明使用了表，可能存在索引回表。using index表示覆盖索引扫描，即查询索引就可以获得足够的数据，不需要再查表。
					using filesort表示进行了额外的排序操作(即不是通过索引的顺序直接排序，而需要额外的内存空间或磁盘进行排序)
	ref：			ref类型的查询使用到的字段，这个字段
	
	
其他
		通过show profile查看具体的耗时操作在哪
		trace查看优化器优化了哪些操作
		
		定期检查表和优化表。检查表是检查表逻辑结构，优化表是整理空间碎片。
		
		
常见优化
		大批量插入数据
			手工情况尽量保证主键的连续性。可以关闭一些校验，如唯一性校验，并开启自动提交。
			代码情况要注意应用程序需要批次处理，首先不要一条一条insert执行
			
		排序优化
			尽量减少额外的排序：where和order by使用相同的索引，且order by的顺序和索引的顺序相同，索引排序字段要么都是升 要么都是降。
			尽量减少select的字段也会减少排序区占用的空间
			
		优化group by	
			默认会对group by的所有字段进行排序
			group by null 可以禁用排序
			
		优化嵌套查询
			利用join和索引往往会更快。一般子查询都要用到临时表，连接查询的话不一定用到关联表。
			
		优化or
			or的每列都要有索引才会使用索引
			or操作一般就是多个查询之后union
			
		分页查询优化
			limit 1000，10 要查出前1010条数据并丢弃前1000条数据
			1）避免全表查询，减少select的字段，缩小范围之后再select出需要的全部字段。尽量使用覆盖索引
			2）增加一个排序字段，查询的时候where条件过滤掉1000之前的数据。思路是将limit m，n优化成limit n。缺点：难以把控，排序字段不能有重复值，删除数据之后也会有影响。
				或者直接用主键，主键不会有重复，删除不要物理删除，一般就不会有断行。问题：复杂where条件的时候依然不适用
			
			
		-----------
		分表
			垂直拆分
				表设计，大字段、不常用字段考虑分到单独的表。
			水平拆分
				数据量大的时候，分开记录。
				数据可以按照时间进行分表。
				