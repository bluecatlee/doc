注册中心
	动态加入：服务提供者通过注册中心动态的把自己暴露给消费者，无需消费者主动更新配置文件
	动态发现：消费者可以动态的感知新的配置、路由规则和新的服务提供者，无需重启服务
	动态调整：注册中心支持参数的动态调整，新参数自动更新到所有相关的服务节点
	统一配置：避免了本地配置导致每个服务的配置不一致的问题
	
	【相比spring cloud，基于发布-订阅模型主动更新配置，同时在注册中心这一层结合了配置中心的概念，eureka默认需要客户端心跳来获取最新的服务清单，同时配置中心需要额外的组件】
	
Dubbo提供了四种注册中心的实现
	Zookeeper		推荐
	redis			没有生产的可靠性验证 依赖redis本身的可用性
	memory			内存，不支持集群，可能出现单点故障，demo级
	multicast		广播方式 不需要注册中心。服务启动时会广播自己的地址，消费者启动时会广播订阅请求，服务提供者收到订阅请求，会根据配置广播或单播给订阅者。
	
工作流程
	服务提供者启动时，向注册中心写入自己的元数据信息，同时订阅配置元数据信息
	消费者启动时，向注册中心写入自己的元数据信息，订阅服务提供者、路由、配置元数据信息
	服务治理中心dubbo-admin启动时 订阅所有消费者、提供者、路由和配置元数据信息
	当有服务提供者离开或新的服务加入时，注册中心服务提供者目录会发生变化，变化信息会动态通知给消费者、服务治理中心
	当消费方发起调用时，会异步的将调用信息、统计信息传给监控中心dubbo-monitor
	
	
【Zookeeper作为注册中心】
	数据为树形目录结构
	节点分为持久节点、持久顺序节点、临时节点、临时顺序节点
		持久节点：		服务注册后保证节点不会丢失，注册中心重启也会存在
		持久顺序节点：	在持久节点基础上增加了节点先后顺序的能力
		临时节点：		服务注册后连接丢失或session超时，注册的节点会被自动移除
		临时顺序节点：	在临时节点的基础上增加了节点先后顺序的能力
		
	dubbo使用zookeeper时 会创建持久节点和临时节点

	示例
		/dubbo/com.bluecatlee.service.TestService/providers/{url}   
		
		root:					根节点 【由注册中心进行分组，组名来自于<dubbo:registry>中的group属性】
			service:			接口全路径名称
				providers:		服务提供者目录 服务者url元数据信息				【4种目录都会被创建为持久节点】
				consumers:		服务消费者目录 消费者url元数据信息
				routers:		路由配置目录 消费者路由策略url元数据信息
				configurators:	动态配置目录 动态配置url元数据信息
				
				
Redis作为注册中心
	同样是Root、Service、Type、URL 四层结构
	Root、Service、Type组成redis的key，value是一个Map结构，Map的key保存URL，Map的value保存超时时间   hset
	
	
【订阅/发布】	
	发布
		服务提供者和消费者都需要把自己注册到注册中心，注册的实现就是发起一个请求，在注册中心上创建一个目录，保存自身url元数据信息。
		取消发布就是取消注册，发起一个请求删除服务数据即可。
	订阅 
		pull	客户端定时轮询注册中心拉取全量配置。
		push	注册中心主动推送数据给客户端
		dubbo默认采用第一次启动时pull全数据，并在订阅的节点上注册一个watcher来维持TCP长连接以供后续接收事件重新拉取(watcher回调) 【这么多长连接占用大量资源？】
		【每个节点都有一个版本号，当节点数据发生变化(事务操作)，版本号就会变化，并触发watcher事件】
		【事务操作：客户端的任何增删改、创建会话和失效操作都是事务操作，会转发给zookeeper集群的leader执行，来保证事务操作的全局时序性】
		【每个节点都有版本号，通过CAS操作来保证该节点数据操作的原子性】
		
		服务暴露时，服务端会订阅configurators用于监听动态配置
		消费端订阅providers、routers、configurators
		
	-zookeeper客户端实现：curator(默认)、zkClient
						  可以在<dubbo:registry>中设置client属性来指定使用的客户端实现
						  
	redis的订阅发布使用的是过期机制和publish/subcribe通道。
	服务提供者发布服务，首先会在redis中创建一个key，然后在通道中发布一条register事件消息。发布者需要周期性的刷新key的过期时间，即续命，如果没有续命成功，key会因超时被redis删除，服务就会被认定为下线。
	消费者首次获取全量数据缓存在本地内存中，后续服务方会通过通道广播，订阅者收到通知后从注册中心拉取新数据，更新本地缓存。
	redis的publish/subcribe通道不是消息可靠的，如果dubbo集群主节点挂了，从节点数据不是最新的，而消费者订阅的是从节点，如何判断服务发布方已经下线？
		通过服务治理中心定时清理redis上所有的key 删除对应key时在通道中发起unregister事件，消费者监听到之后删除本地对应的数据
		
【缓存机制】
	消费者或服务治理中心从注册中心获取注册信息后会做本地缓存，内存中保存一份，磁盘中也会持久化一份。
	启动时首先加载本地磁盘文件中的配置到内存中，如果注册中心无法连接，就会使用本地缓存来加载invokers
	
	缓存的保存和更新有同步和异步两种方式，异步就是使用线程池异步保存。
	
【重试机制】
	发起注册失败、取消注册失败、发起订阅失败、取消订阅失败、通知失败都会添加都对应的集合中，然后在定时器中按照一定的策略进行重试
	
	
【与eureka区别】
	
						  
						  