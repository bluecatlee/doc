Cluster层是集群容错层
	不同的Cluster实现会生成不同的ClusterInvoker，调用其invoke方法开始调用流程
	获取可调用的服务列表，通过Directory获取，并使用Router进行筛选过滤，最终返回剩余的列表
	会根据扩展点配置选择具体的负载均衡实现，然后选择出一个可以调用的服务
	然后做RPC调用，会保存Invoker到RPC上下文，然后调用并处理结果。对于调用出现的异常、失败等情况，每种容错策略都有不同的处理方式。
	
容错机制
	Failover	出现失败时会重试其他服务器，可以设置重试次数。【默认机制】
				重试适合读操作或者幂等的写操作，重试本身也是负载均衡的。注意重试会增加延迟以及下游服务的负载。
	Failfast	快速失败。请求失败后，快速返回异常结果，不重试。适用于调用非幂等的接口
	Failsafe	出现异常时直接忽略异常。不关心调用是否成功，调用结果失败也不会影响外层调用。适用于不重要的日志同步。
	Failback	请求失败后，自动记录在失败队列中，由一个定时线程池定时重试，适用于异步或者最终一致性的请求。
	Forking		同时调用多个相同的服务，只要有一个返回，就会立即返回结果。适用于实时性极高的场景。
	Broadcast	广播调用所有可用的服务，适用于服务状态更新的广播。
	Mock		调用失败时返回伪造的相应结果，或者强制返回伪造的结果而不发起真实调用 测试用，或者用来做服务降级
	Available	请求不做负载均衡，遍历获取到第一个可用的节点就对其发起调用，如果没有可用节点则抛出异常
	Megeable	把多个节点的请求结果进行合并
	
	各个机制对应的就是不同的Cluster实现 如FailoverCluster
	
	
Directory
	StaticDirectory
	RegistryDirectory   动态列表实现
	
更新路由规则
	override:// 协议的URL会覆盖更新本地URL中对应的参数
	empty:// 协议的URL则会清空本地的配置
	
	
路由
	condition	条件路由  使用condition:// 协议
	file		文件路由，文件就是脚本，如js、groovy，然后匹配对应的脚本路由做解析
	script		脚本路由，使用jdk自带的脚本解析器解析脚本并运行，默认js脚本
	


负载均衡LoadBalance
	特性
		粘滞特性：用于有状态服务，尽可能让客户端总是向同一个提供者发起调用，除非该提供者挂了才会再切到另一台  <dubbo:protocol sticky="true">
		可用检测：默认开启。对所有的服务做是否可用的检查，如果不可用，会再次做负载均衡
		避免重复调用：对于已经调用过的远程服务，避免被重复选择，主要是避免高并发场景下某个节点瞬间被大量请求。
		
	算法
		dubbo内置了4种
		RandomLoadBalance			默认随机负载均衡。按权重设置随机概率，有利于动态调整。
		RoundRobinLoadBalance		轮询。按公约后的权重设置轮询比例。问题：请求量大时，响应性慢的提供者会逐渐积累请求，时间长了请求都会卡在这台机器。
		LeastActiveLoadBalance		最少活跃调用数。活跃数指调用前后的计时差，较慢的机器应该接收较少的请求。
		ConsistentHashLoadBalance	一致性Hash
		
		权重轮询分为普通权重轮询和平滑权重轮询
		平滑权重轮询在轮询时会穿插其他节点，让整个服务器的选择比较均匀，避免高流量情况下某个节点流量暴增。
		dubbo高版本默认是平滑权重轮询，nginx中也有平滑权重轮询
		
		一致性hash最大的好处就是节点新增、节点下线比较平稳。缺点就是节点可能分布的不均匀，解决办法就是使用虚拟节点。
		
		