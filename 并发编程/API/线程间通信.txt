wait/notify机制
	（可以通过共享变量来进行类似线程间通信的功能，但是一般需要无限循环判断共享变量，浪费cpu，灵活性也差）
	
	wait()
		使当前执行wait()方法的线程等待，同时会释放锁，直到收到通知或被中断为止。
		调用wait之前，线程必须获取该对象的对象锁，即只能在同步方法或同步代码块中使用wait()
		通知继续执行时，需要重新获得锁。
			
	notify()
		必须获得锁才能使用notify，即只能在同步方法或同步代码块中使用notify
		通知wait状态的线程，重新获取锁，执行之后的代码。多个线程处于wait时，会按照顺序通知，只通知一个。
		调用notify不会立即释放锁，需要等待所在同步区执行完再释放锁，此时wait状态的线程才能获取锁。
		
	notifyAll()	
		唤醒全部等待同一个锁且状态为wait的线程。但是notifyAll可能是倒序唤醒所有wait的线程

	wait(long timeout)				等待超过时间后会自动唤醒，并尝试获取锁    【wait(0)永远等待，必须等到通知】
	wait(long timeout, int nanos)
		
--------------------------		
线程阻塞blocked发生的情况	
	调用了sleep方法，主动让出执行权
	等待锁
	wait()等待通知
	调用了阻塞I/O，在方法返回前会一直阻塞
	调用了suspend()方法
	
-------------------------
中断wait状态下的线程，该线程会抛出InterruptedException	
唤醒的顺序主要还是看jvm实现

------------------------------------
wait/notify可以实现生产者消费者
	注意过早唤醒的问题，用while循环替代if
	假死：所有线程都在等待状态。在生产者消费者模式出现的原因是唤醒了同类，解决办法：使用notifyAll，同类异类全部唤醒
	对于多生产和多消费，使用while结合notifyAll()
	
	
	
	
#####################################################################################################################################################################
管道	
	管道流是一种特殊的流，可以在线程间通信。输入管道和输出管道要先connect连接才能传输数据。
	PipedInputStream PipedOutputStream
	PipedReader PipedWriter
	
	
#####################################################################################################################################################################
join
	线程加入
	会让加入的线程获得执行权(是否立即执行还得看竞争)，等待线程对象销毁之后，才会执行原线程（在哪个线程执行的join方法，就会把这个线程挂起）。
	join() 方法内部使用了wait()，所以join也会释放锁
	比如main线程调用了t.join(),首先会获得线程对象t的锁，然后执行wait(),即main线程会进入等待并释放锁，直到该对象唤醒main线程。【线程销毁的时候会调用notifyAll()】
	
	对一个join了其他线程中断，该线程会抛出InterruptedException，其实就是中断wait状态下的线程
	
	void join()
	void join(long millis)						超时时间就是wait的时间
	void join(long millis, int nanos)