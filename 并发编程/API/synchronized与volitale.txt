非线程安全往往是实例变量，而方法内部私有的变量是线程安全的

synchronized原理
	如果使用同步方法，则生成的字节码指令，在方法的flag上会标记ACC_SYNCHRONIZED。调用方法时就会先判断有没有获取锁，并在方法执行完成之后释放锁。
	如果是同步代码块，则字节码中会使用monitorenter和monitorexit执行进行同步处理。这也是为什么同步代码块也叫监视器锁。
	
锁重入支持继承环境
同步代码块或同步方法中出现异常会自动释放锁
注意：Thread的sleep方法和suspend方法不释放锁
子类重写的父类同步方法可以不是同步的，即synchronized在重写方法时不是必须的	

PrintStream的println()方法是同步的

每个类的Class类实例只有一个，是单例的

一般不用String类型的对象作为锁对象，因为String常量池的原因，直接申明式的字符串引用的是常量池中的同一个对象。注意：new String()方式不一样

获得锁之后不要改变锁对象(地址)，否则可能出现一些不符合预期的结果


##############################################################################################
volitale
	可见性
		b线程能立马看到a线程更改的数据。就是强制将值直接写到主内存，强制从主内存读取数据。避免了主内存与线程私有内存(工作内存)之间不同步的问题。
	原子性
		32位系统，针对long和double数据类型没有实现写原子性，需要加volitale
		64位系统取决于具体的实现，x86架构的64位jdk是实现了long double的写原子性的
		
		volatile并不保证自增操作是原子的 因为自增是三步。自增操作要保证原子性可以使用锁或者Atomic原子类
		
	禁用指令重排序	
		JIT可以动态的改变程序运行的顺序，提高程序运行的效率。当指令对应的操作之间没有依赖关系时，就可能会进行重排序。
		volatile变量相当于一个屏障，该变量之前的指令不能排序到它后面，该变量后面的指令不能排序到它的前面。synchronized也有同样的特性。