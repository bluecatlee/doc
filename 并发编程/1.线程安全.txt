线程
	优点：发挥多处理器的优势，建模简单，异步事件简化处理，用户界面GUI响应灵敏
		  (单线程程序必须使用非阻塞I/O，这种I/O的复杂性会提升)
	缺点：安全性问题复杂。活跃性问题(死锁、饥饿、活锁)，性能问题(线程切换开销很大，处理不好得不偿失)	  
	
#####################################################################################################################################################################################
【线程安全性】
	线程安全的类构成的程序不是绝对的线程安全的，线程不安全的类构成的程序也可能是线程安全的。
	
	定义：当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些线程将如何交替执行，并且在主调代码中不需要任何额外的同步或协调，这个类都能表现出正确的行为，那么这个类就是线程安全的。
	
	无状态对象一定是线程安全的。
	对象的状态一般是指对象内部可变变量的状态(的组合)，多个变量时需要所有变量使用同一个锁才能保证线程安全
	
	原子性
		某些指令本身是原子性的
		使用java.util.concurrent.atomic包下的原子变量类 AtomicLong AtomicReference
		加锁
		
	竞态条件Race Condition
		由于不恰当的执行时序导致出现不正确的结果。最典型的就是"先检查后执行"、"读取-修改-写入(如自增)"
		竞态条件不同于数据竞争
		
	锁
		内置锁：也叫监视器锁、互斥锁，即同步代码块，可重入(同一个线程获取一个它已经持有的锁会成功)
				普通synchronized方法的锁是方法调用所在的对象 静态synchronized方法的锁是Class对象
				
####################################################### 对 象 的 共 享 #####################################################################################################
	 
【可见性】
	 失效数据

	线程安全的类保证了最低安全性 但是不是绝对安全的

	非volatile类型的64位变量long 、double，jvm允许将64位的读操作或者写操作分解为两个32位的操作，但是一般的实际实现还是保证了原子性。
	即64位操作可能是非原子的
	
	加锁的含义不仅仅是互斥行为(原子性)，还包括内存可见性。所有线程在同一个锁上同步可以确保看到共享变量的最新值，而不是失效数据
	
	volatile 
		确保变量的更新操作通知到其他线程。volatile变量不会被指令重排序，不会被缓存到寄存器
		是比synchronized更加轻量级的同步方式，因为不需要加锁，不会使线程阻塞。
		慎用: 确保自身状态的可见性，确保其所引用的对象的状态的可见性，标识一些重要的生命周期事件
		volatile仅保证可见性 不保证原子性
		
	---------------------------------	
【发布与逃逸】	
	发布对象publish	
		使对象能在当前作用域之外的代码中使用
		发布内部状态可能会破坏封装性，破坏线程安全性。不该发布的对象被发布就叫逸出escape
		
		发布的方式
			将对象的引用保存到一个公有的静态变量中，任何类和线程都能看到该对象
			集合(或数组)元素是对象 集合被发布了 集合中的对象也被发布了
			发布的对象的非私有域中引用的所有对象都会被发布
			非私有方法返回一个对象的引用
			发布一个内部类的实例可能会导致隐式的this引用逸出 (要避免在构造函数中使this引用逸出，否则就是不正确构造）
			
		安全发布
			发布不可变对象是安全的，可以任意发布
			发布事实不可变对象也是安全的 事实不可变对象就是技术上是可变的，但实际场景中，发布后状态不会再改变的对象。
			Date是可变的，可以用synchronizedMap包装一层之后再使用
			如果使用static的SimpleDateFormat(线程不安全)，static会导致所有线程都可以使用，这种方式处理日期会出问题 
			
			可变对象必须安全发布 而且必须是线程安全的或某个锁保护起来
			
			
【线程封闭】
	单线程内访问数据就不需要同步。把对象封闭在一个线程中，对象也不需要是线程安全的。
	Swing的事件分发线程就是这种思路
	JDBC的Connection也是这种思路。连接池是线程安全的，但是Connection不是线程安全的
	大多数的请求如Servlet一般也是单个线程采用同步的方式来处理的，所以这个请求中申请的Connection会被封闭在当前线程中
	
	1)Ad-hoc线程封闭
		维护线程封闭性完全由程序实现来承担。不推荐自己去实现
		volatile变量上存在一种特殊的线程封闭：只有一个写线程，其余都是读线程，此时也是线程封闭的，因为volatile保证了可见性
		
	2)栈封闭
		栈封闭是线程封闭的一个特例。只能通过局部变量才能访问对象，局部变量的固有属性就是封闭在线程之中，因为栈内存不是线程共享的。
		
	3)ThreadLocal类
		本地线程变量。将变量绑定到当前线程中 底层是Map<Thread,T>
		如JDBC的Connection 在线程中维护一个全局的数据库连接，不需要调用每个方法的时候都传递一个Connection对象。 类似的事务上下文Transaction Context与线程关联起来
		ThreadLocal变量类似全局变量，会降低代码的可重用性 增加隐式的耦合
		
【不变性】
	如果对象的状态不会改变，就没有并发问题。一个对象在创建之后不可修改，这个对象就是不可变对象。不可变对象一定是线程安全的。
	
	final
		final类型的域是不能修改的，对于对象而言，只是不能修改对象的地址，对象如果是可变的，那对象本身还是能修改。
		final能保证初始化的安全性，共享的时候无需同步
		推荐能用final的字段就用final 推荐能private就用private
		
对象安全共享的几个策略
		线程封闭
		只读共享：包括不可变对象是事实不可变对象
		线程安全共享：线程安全的对象，内部实现了同步。调用者不需要进一步的同步。
		保护对象：调用者还需要使用同步
	
-----------------------------------------------------------------
一些设计思路
	
一些基本的容器不是线程安全的 如ArrayList HashMp
Collections.synchronizedList等就是将这些线程不安全的类进行包装(实例封闭，SynchronizedCollection是Collection的实现，把不安全的集合对象作为final域封装，所有方法操作加上同步之后调用原容器方法)		
		
监视器模式
	内置锁或者使用私有的锁对象。
		