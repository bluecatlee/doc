活跃性问题

死锁是最常见的活跃性问题
jvm无法从死锁中恢复，数据库可以(检测到一个组事务死锁时，会牺牲/放弃一个事务，使其他事务执行)

锁顺序死锁
	两个线程以不同的顺序获得相同的锁。解决：所有线程以固定的顺序来获得多个锁
动态的锁顺序死锁
	锁是传入的外部对象，但是传入的外部对象的顺序刚好互换时可能造成死锁。
在协作对象间发生的死锁
	在持有锁的情况下调用外部方法，外部方法中如果也需要获取其他锁，就有可能死锁。解决：尽量使用开放调用(如果调用某个方法时不需要获得锁，这种调用就叫开放调用)
资源死锁
	
	
死锁的避免与恢复
	使用支持定时的锁	
		Lock
	通过线程转储信息来分析死锁	
	
-------------------------
其他活跃性问题
	饥饿
		某个线程永远获取不到执行权，或者锁中执行无限循环，其他线程将永远无法获取到锁
		解决：尽量不修改线程的优先级(java中线程的优先级只是个标识，与平台实现有关，如果修改可能会造成奇怪的行为)
	响应性差
	活锁
		如：毒药消息。系统永远在执行一个错误恢复的逻辑。
		解决：在重试机制中加入随机性。如重试等待时间按照指数级增长。
	丢失信号
	
	
	