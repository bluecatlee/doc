基础功能
	请求方法	  req.method
	路径解析  	  根据路径查找服务器的文件或者根据路径选择控制器。通过req.url获取之后 使用url模块解析
	查询字符串	  位于路径后 node使用querystring模块处理这部分数据
	Cookie		  HTTP是无状态协议，cookie是最早的保存会话状态的一个方案
	              cookie保存在req.headers.cookie
				  
				  cookie:
					减小cookie的大小
					为静态组件使用不同的域名 减少无效的cookie的传输
					减少DNS查询
					
					可以被篡改(除非设置httpOnly)
					无法保护敏感数据
					
					一般结合服务端session一起使用，cookie中只保存约定的会话id【口令】。
					如果cookie被禁用，可以采用查询字符串的方式代替cookie来保存会话id，但是这种方式更不安全，因为cookie至少只能当前浏览器使用。
					此外还有ETag技术
					
	Session		  服务端会话				
					缺点：占内存，随着用户的增多，内存占用会越来越大，进而引起gc次数增加，引起性能问题
					      如果启用了多进程，用户进程之间的数据不共享 造成数据不一致问题
					一般考虑将会话数据存储到外部如redis，session集中化。利用redis高速缓存、没有gc问题和内存限制问题(相对而言)，并且redis的过期策略更合理高效。	  
					
					
					口令碰撞成功的问题
						服务端生成口令时，对口令进行加密，生成签名值一并返回。
						前端传参必须传递口令和签名值，要同时穷举出口令和签名值且匹配的概率更低。
						如果攻击者获取到了正确的用户口令和对应的签名，他就依然可以伪装。
						所以生成签名的原始信息里要包含用户的特有信息如ip、用户代理信息等，攻击者如果通过XSS漏洞获取到cookie但是他在另一台机器上，也不能通过签名的验证。
						
	缓存
				  一般来说，缓存只应用在GET请求中
				  
				  条件请求：
					请求时设置请求头If-Modified-Since，它将询问服务器该文件在这个时间之后是否发生修改过，修改过服务器就会返回最新的文件；
					否则服务器响应304，客户端就使用其本地缓存的版本。
					缺点：保存的是时间戳，秒级的，更细级别的文件变化将无法立即生效；文件的时间戳改动不代表文件内容产生了变化。
					
					  ETag
						服务端生成Entity Tag，实体标签，可以是文件内容的hash值，文件内容一旦发生变化，ETag值将发生变化，这样就避免了文件时间戳变化但内容没变的问题。
						同样得结合条件请求，比如请求头设置If-None-Match
					
					条件请求时，不管是否能够使用本地缓存，客户端也需要等待服务端响应才能决定。
					
					
				  设置客户端过期
					  服务端响应时可以直接在响应中设置Expire过期时间，客户端后续请求同一资源时只要没过期就使用缓存。
						 缺点：客户端服务端时间可能不一致，导致客户端服务端不一致问题。
						 
					  Cache-Control机制，可以使用max-age属性控制缓存存活的时间(毫秒数)，而不是GMT时间，还有其他选项的控制	 
					  
					  问题：服务端响应之后无法控制客户端过期时间，服务端无法主动使客户端缓存失效
					  解决：为缓存设置版本号。浏览器是根据URL进行缓存的，可以对URL设置路径参数，参数值为版本号或者文件内容的hash值，
					        这样参数变化后，浏览器发起的请求是新的请求，不会走缓存。
							
	Basic认证
				  Authorization: Basic {token}
				  token的内容是base64(username:password)	  
				  
				  最经典的认证方式，传输不安全，近乎明文传输密码，一般只有在HTTPS情况下才使用
				  
	
数据上传
	表单数据
	附件上传
	安全	
			      内存限制
					超过限制则相应400
				    数据流导向到磁盘中再慢慢处理
				  CSRF
                    服务端响应时生成一个随机值保存在session中，并相应给前端，前端存储(比如通过隐藏域)，后续请求带上这个csrf_token值				
					验证Referer信息
					
路由解析
	文件路径型
		静态文件	
		动态文件	早期的asp php都是这种方式，会根据文件后缀去匹配对应的脚本解析器
	MVC
		根据URL寻找到对应的控制器
			手工映射：需要提前维护映射关系，自行维护到配置文件或者项目启动时框架自动映射
			自然映射：不需要维护映射关系，就是约定了一个规则，根据url能够直接到对应的目录下的某个方法。如果发生变动，代码改动较大
			
	RESTful
		通过URL设计资源，通过请求方法定义资源的操作，通过Accept决定资源的表现形式。而传统的MVC中操作主要体现在URL上
		
		
中间件
	类似于java中的filter。可以采用Connect的设计，通过尾触发的方式实现
	每个中间件应该有异常处理，异常处理也可以是一个中间件
	
	
页面渲染	
	内容响应
		MIME：浏览器会根据不同的MIME类型选择不同的渲染方式。来自于Content-Type
		附件下载：Content-Disposition值是inline时表示内容只需查看，值是attachment时表示下载
		对于响应json、响应跳转时可以进行通用的封装
	视图渲染
		设计render方法进行渲染 需要模板+数据
	模板
		最原始时通过CGI或者servlet直接输出HTML，后来发展为服务端动态网页技术如jsp asp php，这就是最早的模板技术。
		模板技术一开始也极度依赖容器提供的上下文环境，后来脱离，如Velocity，这个时期依旧有语言不互通这个最大问题。
		再后来到Mustache的弱逻辑模板 {{}} 开拓了思路
		