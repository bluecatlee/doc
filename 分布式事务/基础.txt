【根源】
事务、分布式事务的本质是要解决数据一致性问题


【事务】
	一个执行单元 里面的操作要么全部执行成功 要么全部执行失败
	【mysql事务】
		ACID (刚性事务)
		事务隔离级别

【spring对事务的处理】
		申明式 编程式事务
		aop 事务拦截器
		事务隔离级别
		事务传播机制

【酸碱理论】
	CAP 三者不可兼得 分布式环境中必然是分区的 所以要么CA(数据强一致) 要么CP
		一致性
		可靠性
		分区容错性

	BASE 对可用性和一致性权衡的结果，无法做到实时强一致性，但是可以实现最终一致性
		基本可用 Base Available
		软状态 Soft state   即中间状态
		最终一致性 Eventually consistent

	---------------------------
	ACID 与BASE是相反的设计思路
		关系型数据库是满足ACID特性、强一致的(事务)
		redis这种nosql的设计理念就是BASE 将对于同一个键的操作串行执行
		BASE也称为柔性事务: 通过业务逻辑将互斥锁操作从资源层面上移至业务层面

【最终一致性】
		类型
			因果一致性
			读己之所写
			会话一致性
			单调读一致性
			单调写一致性
			
				关系型数据库的备份也是最终一致性的
				
		实现模式
			<可靠消息模式>
				一、保证消息投递 (队列一般都实现了事件的持久化和at least once的投递模式)
					
					问题：
						消息投递出去 但是没有收到mq响应投递成功
						消息投递出去 但是本地服务挂了 消费者执行了
					
					解决：
						1）本地事件表
							发送消息状态和业务数据保存在一个数据库中，由本地事务保证更新业务和发布事件的原子性
						2）外部事件表
							将事件状态独立成一个服务 避免与业务耦合
							
				二、避免重复消费 （消费服务必须实现幂等性）
					问题：消息执行顺序
					解决：
						1）消息加时间戳 记录最后处理的事件的时间戳 如果收到的事件时间戳早于已处理的 则丢弃
							不同服务器的时间同步可能存在问题 使用全局的递增序号(雪花算法)替换时间戳
						2）如果操作不具有幂等性 需要单独记录事件的处理状态 如果执行过返回上次的执行结果 否则调度执行时间	
						   可以在消费业务上加个类似过滤器的实现
					
					优化：
						消费业务开销小 而记录事件处理开销反而大时 可以选择重复处理(若没有多个消息执行顺序的问题) 
					
					
			<业务补偿模式>
				异常：业务异常和技术异常(技术异常不包括代码bug 只是网络异常等)【分布式事务不是解决代码bug的！】
				补偿模式尽量只用在无法避免业务异常的情况下 尽量优化业务(如账户余额不足异常应通过预先冻结金额来避免)
				
				补偿的关键在于业务流水的记录 
				
				需要定时重试保证补偿的完整性 补偿业务本身需要保证幂等性
				重试机制：
					不能一味的失败就重试 会增加服务器压力 大面积异常可能造成服务直接不可用
					需要针对不同的情况采取不同的重试策略
					
				说明：
					补偿机制不是回退到业务发生前的状态 而是逆操作 因为可能有别的业务修改了数据状态
					补偿不一定是严格的逆向顺序 根据实际情况可以按照优先级补偿甚至并发补偿
					
				缺点：
					没有隔离性 整个业务的任何阶段的状态对于其他服务都是可见的
					协调服务本身需要很高的可用性 健壮性
				
			<TCC模式>
				Try Confirm Cancel
				包含一个主业务服务和多个从业务服务 主业务服务发起一个业务 此外需要一个TCC服务实现活动日志管理器/统一管理的功能(一般由实现成TCC框架)
				从服务必须提供对应的Try Confirm Cancel接口 confirm和cancel需要保证幂等性
				工作服务可以指定try操作的超时时间 主动的cancel预留的业务资源 实现自治的微服务
				
				TCC有一定的隔离性 因为直到commit过程才提交
				不需要业务流水的记录
				
				TCC不能保证百分百的一致性
					如果TCC服务框架向某个从业务服务提交commit时有超时则会产生不一致 即heuristic exception 不可避免
					
					需要TCC服务框架增加超时机制以及重试机制
					从服务本身要保证幂等 并增加超时机制
		
		以上三种模式是常见的解决方案 但都不是绝对的保证 有时需要一定的人工干预以及最终的对账

【柔性事务】	
	两阶段型
	补偿型
	异步确保型
	最大努力通知型	

	
	
【XA分布式事务协议】
	DTP模型：AP(应用程序) TM RM
	XA协议两个核心：事务管理器TM、本地资源管理器RM(一般由数据库实现)
	J2EE对XA协议的支持：JTA(Java Transaction API).   注：JDBC是不支持分布式事务的
						JTS(Java Transaction Service)

	2PC 强一致 中心化的原子提交协议
			（中心化：协调者节点和多个参与者节点）
		1） 请求/表决阶段 (prepare/vote_request) 协调者向所有参与者节点发起请求 参与者开启事务执行操作但不提交 并告知协调者能否处理(vote_commit/vote_abort)
		2） 提交/执行阶段 (global_commit/global_rollback) 协调者通知所有节点提交/回滚 参与者进行提交或回滚 并反馈给协调者(ack)
		问题
			性能问题非常严重 阻塞
			协调者单点故障 直接导致整个事务无法最终完成
			数据不一致 部分参与者消息未收到/超时等
			
	3PC
		1） CanCommit 准备阶段 检查参与者自身能否对事务进行操作
		2） PreCommit 多了一个阶段 开启事务执行操作 并记录日志 但不提交 （预提交状态）
		3） DoCommit 参与者增加超时机制 参与者如果等待协调者最终的指令超时则本地提交 解决2PC中的协调者超时导致的整个事务挂起无法释放资源
		问题
			依然没解决数据不一致的问题
		
		

------------------------------------------------------------------------------
		
扩展


【FLP不可能性】
	在异步通信场景，即使只有一个进程失败，也没有任何算法能保证非失败进程达到一致性！


【一致性算法】

	leader选举类
		paxos
		viewstamp

	分布式事务
		2PC TCC

	以一致性为主
		Cassandra的W R N 可调节一致性

	以租赁机制为主的
		分布式锁(目前还没有纯粹的分布式锁)

	以失败探测为主的
		gossip
		phi
		心跳机制

	异步解耦为主的
		各种消息队列

	以弱一致性 因果一致性 顺序一致性为主的
		开源较少