【根源】
事务、分布式事务的本质是要解决数据一致性问题


【事务】
	一个执行单元 里面的操作要么全部执行成功 要么全部执行失败
	【mysql事务】
		ACID (刚性事务)
		事务隔离级别

【spring对事务的处理】
		申明式 编程式事务
		aop 事务拦截器
		事务隔离级别
		事务传播机制

【酸碱理论】
	CAP 三者不可兼得 分布式环境中必然是分区的 所以要么CA(数据强一致) 要么CP
		一致性
		可靠性
		分区容错性

	BASE 对可用性和一致性权衡的结果，无法做到实时强一致性，但是可以实现最终一致性
		基本可用 Base Available
		软状态 Soft state   即中间状态
		最终一致性 Eventually consistent

	---------------------------
	ACID 与BASE是相反的设计思路
		关系型数据库是满足ACID特性、强一致的(事务)
		redis这种nosql的设计理念就是BASE 将对于同一个键的操作串行执行
		BASE也称为柔性事务: 通过业务逻辑将互斥锁操作从资源层面上移至业务层面

【最终一致性】
		类型
			因果一致性
			读己之所写
			会话一致性
			单调读一致性
			单调写一致性
			
				关系型数据库的备份也是最终一致性的
				
		实现模式
			<可靠消息模式>
				一、保证消息投递 (队列一般都实现了事件的持久化和at least once的投递模式)
					
					问题：
						消息投递出去 但是没有收到mq响应投递成功
						消息投递出去 但是本地服务挂了 消费者执行了
					
					解决：
						1）本地事件表
							发送消息状态和业务数据保存在一个数据库中，由本地事务保证更新业务和发布事件的原子性
						2）外部事件表
							将事件状态独立成一个服务 避免与业务耦合
							
				二、避免重复消费 （消费服务必须实现幂等性）
					问题：消息执行顺序
					解决：
						1）消息加时间戳 记录最后处理的事件的时间戳 如果收到的事件时间戳早于已处理的 则丢弃
							不同服务器的时间同步可能存在问题 使用全局的递增序号(雪花算法)替换时间戳
						2）如果操作不具有幂等性 需要单独记录事件的处理状态 如果执行过返回上次的执行结果 否则调度执行时间	
						   可以在消费业务上加个类似过滤器的实现
					
					优化：
						消费业务开销小 而记录事件处理开销反而大时 可以选择重复处理(若没有多个消息执行顺序的问题) 
					
					
			<业务补偿模式>
				
				
				
			<TCC模式>
			

【柔性事务】	
	两阶段型
	补偿型
	异步确保型
	最大努力通知型	

	
	
【XA分布式事务协议】
	DTP模型：AP(应用程序) TM RM
	XA协议两个核心：事务管理器TM、本地资源管理器RM(一般由数据库实现)
	J2EE对XA协议的支持：JTA(Java Transaction API).   注：JDBC是不支持分布式事务的
						JTS(Java Transaction Service)

	2PC 强一致 中心化的原子提交协议
			（中心化：协调者节点和多个参与者节点）
		1） 请求/表决阶段 (prepare/vote_request) 协调者向所有参与者节点发起请求 参与者开启事务执行操作但不提交 并告知协调者能否处理(vote_commit/vote_abort)
		2） 提交/执行阶段 (global_commit/global_rollback) 协调者通知所有节点提交/回滚 参与者进行提交或回滚 并反馈给协调者(ack)
		问题
			性能问题非常严重 阻塞
			协调者单点故障 直接导致整个事务无法最终完成
			数据不一致 部分参与者消息未收到/超时等
			
	3PC
		1） CanCommit 准备阶段 检查参与者自身能否对事务进行操作
		2） PreCommit 多了一个阶段 开启事务执行操作 并记录日志 但不提交 （预提交状态）
		3） DoCommit 参与者增加超时机制 参与者如果等待协调者最终的指令超时则本地提交 解决2PC中的协调者超时导致的整个事务挂起无法释放资源
		问题
			依然没解决数据不一致的问题
		
		

------------------------------------------------------------------------------
		
扩展


【FLP不可能性】
	在异步通信场景，即使只有一个进程失败，也没有任何算法能保证非失败进程达到一致性！


【一致性算法】

	leader选举类
		paxos
		viewstamp

	分布式事务
		2PC TCC

	以一致性为主
		Cassandra的W R N 可调节一致性

	以租赁机制为主的
		分布式锁(目前还没有纯粹的分布式锁)

	以失败探测为主的
		gossip
		phi
		心跳机制

	异步解耦为主的
		各种消息队列

	以弱一致性 因果一致性 顺序一致性为主的
		开源较少