服务容错保护

	常见思路
		客户端容错
			超时机制 一般http调用 rpc调用都自带了超时 需要根据实际情况调优
			重试机制 重试机制适用于需要保证强一致性的场景 重试尤其要注意多次重试之间的间隔以及被调用者接口的幂等
					 重试次数也会影响服务的响应性，如果需要重试次数较多，考虑使用队列保存重试消息，异步消费。
		服务端容错
			限流：如控制并发或者控制并发访问的速率
				  比如可以用Semaphore来限制并发连接数，控制速率往往需要令牌桶 活动窗口等类似方式
			削峰：上下游服务由于业务逻辑不同，响应性不同，吞吐量不一致，可以使用队列，异步处理	  
			断路器
			线程隔离/舱壁隔离
			
		业务系统架构层面 如果允许，要避免服务调用层次的深度，更要避免服务之间的循环依赖
		
		服务容错往往结合需要回退、补偿等机制
		
	
	服务雪崩
		如：下游服务由于网络原因或吞吐量瓶颈，响应时间延长，响应性降低，导致上游服务线程挂起，这些线程得不到释放，
		长期占用资源并使得上游服务无法创建新的线程来处理请求，上游服务变得不可用，并继续向上层蔓延，最终导致整个系统瘫痪。
		此外，如队列消息积压，长时间得不到处理也会导致内存资源耗尽，传播到生产者服务，导致生产者服务不可用。

Hystrix断路器
	简单介绍：
		熔断器模式可以防止我们的系统不断地尝试执行可能会失败的调用，使得我们的系统继续执行而不用等待修正错误，或者浪费CPU时间去等到长时间的超时产生。
		熔断器模式也可以使我们系统能够检测错误是否已经修正，如果已经修正，系统会再次尝试调用操作。
		
		
	基本原理：	
		
		
		
		
	
	常用注解：
		@EnableCircuitBreaker     应用主类  开启断路器功能
		@SpringCloudApplication   应用主类  包含了@SpringBootApplication @EnableDiscoveryClient	@EnableCircuitBreaker
		@HystrixCommand			  方法	    给方法添加断路器，【断路器是在调用方添加的】
			fallbackMethod		  指定降级方法
			commandKey
			
			
【命令模式】
	行为请求者与行为执行者的解耦
	适用于记录日志、撤销操作、队列请求，也可以代替类似"回调(提前注册一个函数，事后某个时机调用)"的功能
	例如：将客户端的请求封装成一个对象，从而可以使用不同的请求对客户端进行参数化
	
	Invoker：调用者，持有一个命令对象，通过命令对象完成具体的业务逻辑
	Receiver：接收者，处理命令的具体业务逻辑
	Command：抽象命令，定义了一个命令的基本操作，如execute undo redo等，当命令操作被调用时会触发接收者的具体执行
	ConcreteCommand：具体的命令实现，通过它来绑定命令操作与接收者之间的关系，将execute操作委托给接收者处理
	
【观察者-订阅者模式】
	实现思路
		wait/notify机制 + 非阻塞队列
		阻塞队列