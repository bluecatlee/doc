API网关服务
	API网关基本作用：请求路由、请求过滤
	
	在微服务架构体系下，使用nginx作为网关时，遇到服务实例增加或者修改的时候，或者服务ip端口产生变化，就需要手工的修改nginx的配置。
	在系统规模很大的情况下，这些手工维护配置的任务会很繁琐且易错。
	所有服务都需要一定的权限校验机制，甚至有些服务需要对请求进行签名校验，大规模服务的情况下，为每个服务编写重复的校验逻辑冗余且难以维护，
	需要统一的校验逻辑，并且是适合架构体系的开发友好的可编程方式的组件/服务来处理。
	一种方案是鉴权服务单独部署，所有服务都会依赖该服务，对其进行直接调用，虽然解决了冗余校验逻辑代码的问题，但是依然有很多冗余的拦截过滤、服务调用代码。
	
	
	Zuul实现了面向服务的路由，在整合服务治理框架之后，能够有效利用服务自动发现的机制，
	默认会以服务名作为ContextPath的方式来创建路由映射，简化了大量的手工配置路由的工作，对于特殊路由也可以进行相应的自定义配置。
	而对于一些校验逻辑，这些业务逻辑不是网关本身提供的，但是Zuul提供了一套过滤器机制，对请求进行前置拦截校验，通过指定规则的请求才会被路由到具体的服务，开发者只需要创建自己的拦截器实现业务即可。
	

Zuul依赖ribbon，维护服务列表。可以实现网关服务进行路由转发的时候进行客户端负载均衡和请求重试 【ribbon维护服务列表可以自己维护或交由其他服务治理框架(Zuul本身也要注册到注册中心才能获取服务列表)】
	依赖actuactor，提供/routes端点来返回当前创建的所有路由规则
	依赖hystrix，通过线程隔离和断路器能够保护网关服务本身
	路径表达式使用Ant风格定义
	
	
基本API：	
	@EnableZuulProxy     应用主类  开启Zuul的API网关服务功能	
	
	ZuulServlet
		区别于DispatcherServlet, 默认/zuul/**路径访问的请求会通过ZuulServlet处理
	
	ZuulFilter 抽象Zuul过滤器类 子类继承并实现过滤规则、顺序及过滤业务。 【Zuul过滤器必须以bean的形式创建后才能在spring中使用，或者直接在定义类上加@Component】
		String filterType()			过滤器类型 决定在请求在哪个生命周期执行 pre表示前置过滤
		int filterOrder()       	过滤器的执行顺序 
		boolean shouldFilter()		判断该过滤器是否需要执行
		Object run()				具体的过滤逻辑，可以在此处设置不路由，并设置响应码和响应内容
		
	RequestContext Zuul请求上下文 可以在整个生命周期的任何地方获取到请求信息(就是把request绑定到了线程上)	
	
	PatternServiceRouteMapper       正则服务路由规则映射定义  如定义类似/v1/serviceA/** 到serviceA-v1服务的映射

常见配置
	zuul
		servletPath					ZuulServlet的访问路径 默认/zuul/**
		prefix						为所有路由规则添加前缀 (慎用，低版本的prefix功能有bug，当path表达式本身以prefix开头时，再添加prefix就会有问题,这个功能的实现不是直接添加前缀？)
		stripPrefix					设置是否移除代理前缀 默认是
		routes
			<route>					路由名 自定义 表示一条路由规则
				path				请求地址 按照规则匹配      
				url					路由到指定地址			  【forward:/path， 使用forward可以进行本地跳转】 【路由到指定地址的话就不会使用到hystrix提供的保护，也不会有ribbbon提供的客户端负载均衡的支持】
				serviceId			路由到指定服务             路由到服务时如何进行url rewrite？貌似不能完全重写
				stripPrefix
				
			<serviceId>=<path>		路由到服务的简写	
			
		ignored-services			定义不自动创建路由的规则  设置为*表示所有服务都不自动创建路由规则
									【集成eureka时，zuul会自动创建映射关系来进行路由 默认会以服务名作为ContextPath的方式来创建路由映射】	
									【微服务体系中 每个服务的接口一级路径应该定为服务名(或包含服务名)，这样接口地址名称才易于辨认】
		ignored-patterns			设置被zuul网关忽略 不进行路由的url表达式	
		sensitiveHeader				设置敏感头部信息 会被丢弃
		addHostHeader				设为true表示在路由转发前为请求设置Host头信息为最初的请求Host信息 否则下游服务接收到的请求的Host信息将是Zuul网关的Host信息
		addProxyHeaders				默认为true 会添加X-Forwarded-*头域，X-Forwarded-*保存客户端的真实ip 端口 路径等信息，因为服务默认收到的请求是被网关转发的，不是原始的。但是网关可以对其修改/伪造
		retryable					关闭重试机制

					
注意点
	【如果多个路由中的path都能匹配请求url，则第一个被定义的会被选择，因为匹配的时候是单纯的线性遍历路由规则进行匹配】【nginx中会进行最优匹配】
	【如果使用properties配置文件的话 配置被加载后，顺序不固定，期望通过配置顺序来选择匹配就不能得到正确的结果，建议用yml实现有序的路由规则】
	
	请求路由时默认会丢掉HTTP请求头中的一些敏感信息，默认包括Cookie、Set-Cookie、Authorization
	
	使用了网关之后需要注意重定向的问题 服务接收到的请求的Host必须是原始请求的Host 而不是网关/代理服务器的Host 否则服务设置的Location重定向地址的主机名将不正确，客户端重定向失败。
	
	
过滤器详解
	ZuulFilter
		过滤器类型【对应了四个生命周期】
			pre			前置 在请求被路由之前被调用			url路径与path路径的匹配过程就是在pre类型的过滤器中执行的
							有标记Servlet类型 包装请求 标记调试标志 处理请求上下文等类型的filter
			routing		在请求被路由时被调用				路由转发的过程就是在routing类型的过滤器中执行的
							主要三种 处理映射到服务的路由 处理映射到url的路由 处理本地路由
			post		后置 在routing和error之后被调用，可以对返回值进行处理
							主要有两种 一种处理有错误的请求响应 一种处理正常的请求响应
			error		在处理请求发生错误时被调用，包括pre routing post过程中发生的错误，需要自己实现
			
	Zuul的异常处理不好，需要在在try catch的catch代码块中获取上下文并设置异常信息，否则后续过滤器无法获取到前面流程的异常信息
	error过滤器执行之后将不会再执行post过滤器	
		
	自定义异常处理：禁用SendErrorFilter并自定义一个post filter处理错误结果，比如可以再转发到/error端点 而/error端点返回属性可以通过重写DefaultErrorAttributes类来实现

【动态加载】
	动态路由
		结合配置中心如Spring Cloud Config使用，依赖外部的代码仓库服务，不够优雅。考虑注册中心中维护配置信息？
	动态过滤器
		过滤器是编码实现的，动态过滤器就需要基于JVM实现的动态语言的帮助，如Groovy
					
					
【服务/接口的命名规则思考】
	如何进行服务的版本控制？
		1.在服务名中添加版本号相关标识			
			适用于服务治理下的服务升级，新服务以不同的服务名注册，客户端相应升级之后就可以使用新服务，客户端不升级就使用旧服务功能。
			不同业务的服务之间的兼容性也能通过服务名中的版本号得以判断
			
		2.在服务的接口名上添加版本号相关标识    
			可以做一些临时的接口的兼容 或者临时暴露一些特定接口 
			对于传统的单体服务的版本控制可以使用这个方式
			
		3.配置化 然后使用类似分布式配置中心的框架来更新配置。可以结合上面的一起使用	
		
其他
	如果在网关这层直接做鉴权服务 往往需要连接数据库及redis缓存等中间件 网关层直连中间件是否合理？
	还是单独鉴权服务 网关层先路由转发到鉴权服务后 鉴权成功再路由到实际业务服务 ？