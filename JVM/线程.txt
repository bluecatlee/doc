并发不一定要依赖线程，也可以使用多进程并发。
线程比进程更加轻量级，可以把进程的资源分配和执行调度分开，各个线程可以共享进程资源，也可以独立调度(线程是CPU调度的基本单位)

线程的实现方式：
	使用内核线程实现
		内核线程KLT就是直接由操作系统支持的线程，由内核完成线程切换，内核通过操纵调度器对线程进行调度，并将线程的任务映射到各个处理器上
		内核线程本身会扩展出轻量级进程
	使用用户线程实现
		一般不是内核线程的就是用户线程UT。狭义的用户线程是内核感知不到的 完全在用户态中
		进程与用户线程是一对多的。单纯使用用户线程的程序很少，因为维护用户线程很复杂。  【轻量级线程 也叫协程】
	使用用户线程加轻量级进程混合实现
		通过轻量级进程作为用户线程和内核线程之间的桥梁
		
	目前对于sun jdk的java线程来说 windows和Linux系统上的java线程都是一对一映射到一个轻量级进程的	
	
Java线程调度
	为线程分配处理器使用权的过程
	协同式线程调度
		线程的执行时间由线程本身控制，线程执行完自己任务之后，主动通知系统切换到另一个线程上。一些语言的协同例程就是这样的实现
		
	抢占式线程调度
		线程由系统来分配执行时间，不会有一个线程导致整个进程阻塞的问题
		线程优先级 Thread.MIN_PRIORITY Thread.Max_Priority共10个优先级
		
状态转换
	新建New：创建后尚未启动的线程处于该状态
	运行Runnable：可能正在执行，可能在等待执行
	无限期等待Waiting：不会被cpu分配执行时间，需要等待显式唤醒
	限期等待Timed Waiting：不会被cpu分配执行时间，不需要显式唤醒
	阻塞Blocked：阻塞是在等待锁
	结束Terminated：已终止的线程状态
	
	
##############################################################################################################################################################################
【线程安全】
	当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何的协调操作，调用这个对象的行为都会或得正确的结果，
	则这个对象是线程安全的
	
	不可变
		不可变Immutable对象一定是线程安全的
		对于基本数据类型来说 申明为final就是不可变的
		对于对象来说，内部的字段申明为final 初始化完成且没有发生this逃逸 这个对象就是不可变的。如String类的方法返回的是新构造的字符串对象 而不是本身 不会影响原来的值
	
	绝对线程安全
		Java中标注为线程安全的类，大部分都不是绝对线程安全的，还需要调用方进行协调。
	
	相对线程安全
		相对线程安全就是平常说的线程安全，保证了这个对象单独的操作是线程安全的，调用方不需要额外的保障。只保障单次操作，对于连续多次调用，就可能需要调用方使用额外的同步措施
	
	线程兼容	
		对象本身不是线程安全的，可以通过调用端正确的使用同步手段来保证对象在并发环境下可以安全的使用。
		不是线程安全指的就是这种情况 java中大部分的类是线程兼容的
	
	线程对立
		无论调用端是否采取了同步措施 都无法在多线程环境中并发使用的代码
		这种方法很少。如Thread的suspend()和resume()方法(已废弃)，System的setIn()、setOut()、runFinalizerOnExit()等
		
【线程安全的实现方法】
	互斥同步：多线程并发访问数据时，保证共享数据在同一时刻只被一个线程使用
		互斥的实现方式：
			临界区Critical Section
			互斥量Mutex   --------最常见的锁就是这种
			信号量Semaphore
			
		Java中使用synchronized关键字作为最基本的互斥手段 重量级的 因为阻塞或唤醒线程都会从用户态转到核心态 需要更多的处理器时间 必要时才使用
		synchronized是可重入的 同一个线程是可以重入同步块的，不会把自己阻塞
		虚拟机对于synchronized的优化就是在阻塞线程之前会加入一段自旋等待的过程 避免频繁的切入到核心态
		
		ReentrantLock可重入锁 与synchronized类似
		ReentrantLock扩展：等待可中断、可实现公平锁(按照申请锁的顺序依次来获得锁)、锁可以绑定多个条件(Condition)
		在synchronized能满足需求的情况下 优先使用synchronized
		
		互斥同步最大的问题就是线程阻塞和唤醒导致的性能问题 也叫阻塞同步。先阻塞 再操作 属于悲观锁
		
	非阻塞同步
		先操作 发现有冲突时 再采取补偿措施(乐观锁)。补偿措施最常见的就是重试，直到成功。
		很多实现都不需要把线程挂起，所以是非阻塞的。
		需要硬件指令集的支持
			测试并设置 Test-and-SET
			获取并增加 Fetch-and-Increment
			交换 Swap
			比较并交换 Compare-and-Swap   CAS		（CAS的ABA问题）
			加载链接/条件存储 Load-Linked/Store-Conditional  LL/SC
			
	无同步方案：不需要任何同步措施，有些方法天生就是线程安全的，因为它不涉及到共享数据的读写
		可重入代码(纯代码)
		线程本地存储Thread Local Storage：如果一个方法要共享的数据能限制在线程内， 就不需要在多线程之间进行同步(例如典型的web架构中的一个请求由一个服务器线程处理)
										  ThreadLocal实现线程独享的功能(volatile易变的实现线程共享变量的功能)
										  
【锁优化】	
	自旋锁与自适应自旋
		减少非必要的内核态的切入 因为很多时候只要稍微等待一会就可以获得锁 
		
	锁清除
		JIT时 对于不存在共享数据竞争的时候 虚拟机会清除掉锁
		依赖逃逸分析技术：如果堆上的所有数据都不会逃逸出去被其他线程访问到，那么它们可以当做栈上数据对待，相当于是线程私有的，就不需要同步加锁
		
	锁粗化
		一般情况下推荐将同步块的范围限制得尽量小
		但是如果一系列的连续操作 都对同一个对象反复加锁和解锁 可以把锁粗化到整个操作序列的外部
		
	轻量级锁
		对于绝大部分的锁 在整个同步周期内都是不存在竞争的 轻量级锁使用CAS操作避免了互斥量的开销。如果有竞争，则会膨胀为重量级锁
		
	偏向锁
		对于绝大部分的锁 在整个同步周期内都是不存在竞争的 偏向锁直接消除了同步操作。如果一个线程获取到了偏向锁，以后只要没有其他线程获取过锁，那这个线程再次请求锁时就不需要再同步了
		