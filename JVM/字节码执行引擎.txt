【栈帧】
	方法调用和执行的数据结构，存储局部变量表、操作数栈、动态连接和方法返回地址等信息。
	局部变量表大小 操作数栈大小都是编译期确定的
	
	【局部变量表】
		以变量槽Slot为最小单位。
		编译时在方法的Code属性中确定了局部变量表的最大容量
		不使用的对象手动复制为null(小技巧 不推荐)
		局部变量定义了但是没有赋初始值是不能使用的 编译期会检查(类变量有两次赋值，一是准备阶段赋初始值，而是初始化阶段赋值)
		
	【操作数栈】
		操作数栈的最大深度也在编译时写入到Code属性
		操作数栈的每一个元素可以是任意的java数据类型
		
	【动态连接】	
		指向运行时常量池中该栈帧所属方法的引用，为了支持方法调用过程中的动态连接
	【方法返回地址】
		正常完成出口：执行引擎遇到方法返回的字节码指令
		异常完成出口：jvm内部遇到异常或athrow指令在本方法的异常表中没有匹配的异常处理器 就会导致方法退出。不会给调用者任何返回值
	【附加信息】
		
		
方法调用
	方法调用不等于方法执行。
	一切方法调用在Class文件里存储的都是符号引用，而不是直接引用，需要在类加载期间甚至运行期间才能确定目标方法的直接引用，此特性即用来动态代理
	
	解析
		类加载的解析阶段 会将一部分符号引用转化为直接引用。
		静态方法、私有方法、实例构造器、类构造器：编译器可知，运行期不变。即这种方法都是类加载阶段解析的，也称为非虚方法。final方法也是非虚方法
		
	分派
		静态分派(静态绑定)
			编译器在重载时通过参数的静态类型而不是实际类型作为判定依据的。静态类型是编译期可知的 (这里的静态类型是外观类型 不是static)
			
		动态分派(动态绑定)
			方法重写：在运行期间根据实际类型确定方法的执行版本
		
		单分派与多分派
			静态分派属于多分派
			动态分派数据单分派     {为什么java是静态语言}
			
动态类型语言支持
	动态类型语言的关键特征：类型检查在运行期。变量无类型 变量值有类型。
	
	java.lang.invoke包
		1.7。在此之前只能通过符号引用来确定调用的目标方法，新的机制MethodHandle，是对字节码方法指令调用的模拟(而反射是代码层次的)
	invokedynamic指令
		invokevirtual、invokespecial、invokestatic、invokeinterface这四个方法调用指令的第一个参数都是被调用方法的符号引用，方法的符号引用是编译时产生