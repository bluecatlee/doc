前端编译器
	javac 即把java文件编译成class文件(源码转成字节码)
	
JIT编译器
	运行期编译器 Just In Time Compiler 即时编译器 把字节码转变成机器码
	
AOT编译器
	Ahead Of Time Compiler 静态提前编译器 把java源码编译成机器码
	
########################################################################################################################################
【javac编译】
	解析和填充符号表
		词法分析：将源代码的字符流转变为标记(Token)集合
		语法分析：根据Token序列构造抽象语法树(AST)
		填充符号表：符号表是由一组符号地址和符号信息组成的表格
	
	插入式注解处理器的注解处理
		使用此技术的框架有hibernate validator和lombok等
	
	语义分析与字节码生成
		标注检查：检查变量使用前是否已申明、变量申明类型和赋值的实际类型是否一致，常量折叠
		数据及控制流分析：检查局部变量使用前是否赋值、方法的每条路径是否有返回值、是否所有的受检异常都被正确处理了
							(局部变量申明为final对运行期没有影响，变量的不变性仅由编译器保障，局部变量包括方法参数)
		解语法糖：对语言的功能没有影响 只是方便程序员使用。运行时不支持语法糖，需要在编译时解语法糖
		字节码生成：语法树 符号表等转成字节码。添加实例构造器和类构造器 把字符串的加操作替换成StringBuffer或StringBuilder的append()操作等
		
#########################################################################################################################################
【语法糖】
	泛型和泛型擦除
		java中的泛型是伪泛型，只在源码中存在，在编译后的的字节码文件中就已经替换为原生类型，并在相应的地方加了强制转换类型的代码。
		在运行期 ArrayList<String>和ArrayList<int>是同一个类。
		擦除是对方法的Code属性中的字节码进行擦除，实际上元数据中还是保存了泛型信息，这就是能通过反射获取到参数化类型的依据
		
	自动装箱、自动拆箱与遍历循环foreach
		装箱还原成Integer.valueOf()
		拆箱还原成Integer.intValue()
		foreach转成迭代器实现
		可变参数转成数组类型的参数
	
	条件编译
		if(true){
			code1;
		} else {
			code2;
		}
		优化后只剩code1;这一行
		
	内部类、枚举类、断言、对枚举和字符串的switch支持、try-with-resource	
	
########################################################################################################################################
【JIT】
	为了提高执行效率 jvm在运行时将热点(Hot Spot)代码编译成与本地平台相关的机器码，并进行各个层次的优化
	
	
	两个即时编译器
		Client Compiler(C1编译器)
		Server Compiler(C2编译器)
		java程序启动时使用-client -server来强制指定虚拟机运行在Client或Server模式。
		一般Hot Spot虚拟机是解释器+其中的一个即时编译器混合工作的，可以使用-Xint只使用解释器或-Xcomp优先使用编译器
		1.7版本以后默认是C2 实际是分层编译
		
	编译对象
		被多次调用的方法：以整个方法作为编译对象，标准的即时编译
		被多次执行的循环体：依然以整个方法作为编译对象 编译发生在方法运行的期间 也成为栈上替换(OSR编译)
		
	热点探测
		基于采样的热点探测
			周期性的检查各线程的栈顶 如果一个方法经常出现在栈顶 则被认为是热点方法(缺点：不精确，会受到线程阻塞等情况的干扰)
		基于计数器的热点探测
			为每个方法建立计数器 (缺点：实现复杂，不能获取到方法的调用关系)
			方法调用计数器：
			回边计数器：统计方法中循环体的调用次数(字节码遇到控制流向后跳转的指令称为回边back edge)
			
	优化技术
		公共子表达式消除：已经计算过的表达式的结果的值复用
		数组范围检查消除
		方法内联：把目标方法的代码‘复制’到发起调用的方法之中，避免发生真实的方法调用。
				  大部分情况下无法进行内联(java中默认的实例方法是虚方法，虚方法在编译期做内联的时候无法确定使用方法哪个版本)，但是一般会激进优化，同时需要预留一个逃生门来回退到优化前的状态
		逃逸分析
			方法逃逸：一个对象作为调用参数传递到其他方法中，对象的作用域就会逃出定义它的作用域
			线程逃逸：把一个对象赋值给类变量或者在其他线程中访问的实例变量
			
			如果确定一个对象不会逃逸出方法，就可以对他进行栈上分配，对象就会随着方法出栈而销毁，降低gc压力；
			如果确定一个变量不会逃逸出线程，那这个变量的读写就不会有竞争，就不需要对这个变量进行同步操作；
			如果一个对象不会被外部访问，并且这个对象可以被拆散的话，将不会真正创建这个对象，而改为直接创建它的若干个成员变量(标量替换)，这些成员变量可以在栈上分配
			
	
		