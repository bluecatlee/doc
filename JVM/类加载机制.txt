类加载机制
	虚拟机把class文件加载到内存，对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型
	
类加载的时机
	类的声明周期：加载 连接(验证 准备 解析) 初始化 使用 卸载
	解析阶段可能是在初始化阶段之后 比如动态绑定
	
	没有明确规定什么时候必须加载 但是明确规定了什么时候必须初始化 要初始化就会先加载
	1). new对象，读取或设置类的静态字段(final除外 因为final已经放到常量池)，调用一个类的静态方法的时候。对应指令new getstatic putstatic incokestatic
	2). 反射
	3). 初始化的时候先触发父类的初始化
	4). 虚拟机启动时，用于需要指定一个要执行的主类(即包含main方法的类)
	5). 动态语言支持的相关技术
	
	注：
		通过子类引用父类的静态字段 不会导致子类初始化 只触发父类的初始化
		通过数组定义来引用类 不会触发此类的初始化
		常量(final)在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类(常量传播优化，已经存储到调用类的常量池中)，因此不触发定义常量的类的初始化
		接口也有初始化 编译器也会为接口生成类构造器 接口初始化不会先初始化父接口
	
##########################################################################################################################################################################		
【类加载】
	加载	
		1)通过一个类的全限定名来获取定义此类的二进制字符流
			不仅仅是class文件，可以从zip包(扩展出jar war ear)、网络(如Applet)、运行时动态生成(如java.lang.reflect.Proxy)、其他文件(如jsp)、甚至数据库
			数组类本身不是类加载器创建的 是虚拟机直接创建的
		2)将字节流所代表的静态存储结构转化为方法区的运行时数据结构
		3)在内存中生成一个代表这个类的Class对象，作为方法区这个类的各种数据的访问入口 (Class对象是特殊的对象 它存在方法区)
		
	验证	
		class文件一般由java源码编译而来 编译会进行校验 编译后的代码是安全的 但是class文件并非都是java源码编译而来 所以虚拟机需要检查class文件(class对应的二进制流)
		1)文件格式验证
			是否以魔数开头
			主、次版本号是否在当前虚拟机处理范围内
			常量池的常量中是否有不被支持的常量类型
			是否有指向不存在的常量或不符合类型的常量
			CONSTANT_Utf8_info型的常量中是否有不符合UTF-8编码的数据
			Class文件的各个部分以及文件本身是否有被删除的或者被附加的其他信息
			...
		2)元数据的验证
			是否有父类(除了Object类 所有类应当都有父类)
			这个类的父类是否继承了不允许被继承的类(被final修饰的类)
			如果这个类不是抽象类 是否实现了父类或接口中要求实现的所有方法
			类中的方法、字段是否与父类产生矛盾(例如覆盖了父类的final字段 不符合规则的方法重载)
		3)字节码验证
			保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作
			保证跳转指令不会跳转到方法体以外的字节码指令上
			保证方法体中的类型转换是有效的...
		4）符号引用验证 
			符号引用中通过字符串描述的全限定名是否能找到对应的类
			在指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段
			符号引用中的类、字段、方法的访问性是否可以被当前类访问
			（可能在解析阶段进行）
	准备
		为类变量(static修饰的变量)分配内存(方法区中)并设置类变量初始值(零值，实际的值是初始化阶段赋值的)
		但如果是static final修饰的变量 则此时会直接设置实际值
	解析
		将常量池中的符号引用替换为直接引用的过程(直接引用就是指向目标的指针、指针偏移量或者句柄)
		1)类或接口的解析
		2)字段解析
			当前类-->接口及父接口-->父类  如果最终查找失败 则抛出NoSuchFieldError；如果成功返回引用，继续进行权限验证，如果没有权限 排除IllegalAccessError
			(一般编辑器检查时出现多次同名字段 则可能会拒绝编译 提示ambiguous）
		3)类方法解析
		4)接口方法解析
	初始化
		初始化阶段才会真正有用户代码(编译后的字节码)执行到
		初始化阶段就是执行类构造器<clinit>()的过程
			
			类构造器<clinit>()
				编译器自动收集类中所有类变量的赋值动作和静态语句块中的语句合并产生的(静态语句块只能访问定义在静态语句块之前的变量，之后的能赋值 但是不能访问)
				与实例构造器<init>()不同 不需要显式调用父类构造器，虚拟机会保证子类的<clinit>()执行之前 会优先执行父类的<clinit>()(虚拟机中第一个被执行的<clinit>()一定是Object类的)
				父类定义的静态语句块要优先于子类的变量赋值操作
				<clinit>()不是一定有的 因为类中可以没有static字段 没有static{}
				接口不能使用static{} 执行接口的<clinit>()不需要先执行父接口的<clinit>() 接口的实现类在初始化时也不需要执行接口的<clinit>()
				虚拟机保证了多线程环境下<clinit>()的安全性 只会有一个线程执行该方法 (同一个类加载器下 一个类型只会初始化一次 哪怕初始化失败了也不会重新初始化)

####################################################################################################################################################################################			
【类加载器】	
	启动类加载器Bootstrap ClassLoader
		虚拟机自身的一部分
		加载<JAVA_HOME>/lib目录和-Xbootclasspath指定目录下的类库
	其他类加载器 独立于虚拟机外部 都继承ClassLoader
		扩展类加载器Extension ClassLoader 
			加载<JAVA_HOME>/lib/ext下所有类库 或java.ext.dirs系统变量指定的目录下的所有类库
		应用程序类加载器Application ClassLoader 也叫系统类加载器
			加载用户类路径(classpath)上的类库。如果没有自定义类加载器 默认就是这个类加载器
	
	双亲委派模型
		如果一个类加载器接收到了类加载请求 首先不会自己去尝试加载这个类 而是把请求委派给父类加载器去完成 每一个层次的类加载器都是如此，
		因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有父类加载器反馈自己无法完成这个加载请求时 子加载器才会尝试自己去加载
		(实际的代码层次的类加载器之间不是继承关系 是组合)
		(自定义类加载器的上级是应用程序类加载器)
		
		好处：如Object这种系统类无论如何都会经过启动类加载器 能保证在不同环境下都是同一个类 防止重写Object等类 保证java的稳定运行	
		
		破坏双亲委派模型
			线程上下文类加载器：如果创建线程时还未设置 则从父线程中继承一个 如果全局范围内都未设置过 则默认是应用程序类加载器。
								JDBC JNDI等所有SPI都使用了类似的方式 实现在父类加载器中请求子类加载器 完成一些需要具体实现才能执行的需求
			OSGi模块化热部署
				每个模块都有自己的类加载器 替换模块时连同类加载器一同替换
		
				  