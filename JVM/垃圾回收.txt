垃圾回收主要是回收堆内存
栈中的内存随着方法的结束或者线程的结束自然释放

【哪些对象可回收】

	1.引用计数法
		给对象添加一个引用计数器 每当有一个地方引用它时，计数器就加一；当引用失效时，计数器就减一。计数器为0的对象就是不会再被使用的。
		缺点：很难解决对象之间相互循环引用的问题。
	
	2.可达性分析算法(jvm使用)
		通过一个GC Roots对象作为起始点 从这个节点开始向下搜索，当GC Roots到某个对象不可达时，则此对象是不可用的。
		可以作为GC Roots的对象：
			虚拟机栈(栈帧中的本地变量表)中引用的对象
			方法区中类静态属性引用的对象
			方法区中常量引用的对象
			本地方法栈中JNI(即Native方法)引用的对象
			
【引用】
	如果reference类型的数据中存储的数值代表的是另外一块内存的其实地址，怎称这块内存代表一个引用。
	
	强引用 StrongReference		new Object() 不会被gc
	软引用 SoftReference		有用但是非必须的对象 系统OOM之前会进行回收 如果内存还是不足则会OOM
	弱引用 WeakReference		非必须的对象 会被gc
	虚引用 PhantonReference		对象的虚引用不会对其本身产生影响 唯一目的就是在这个对象被gc时收到一个系统通知
	
可达性分析之后，如果对象不在引用链上，则会被第一次标记并进行筛选，如果该对象没有重写finalize()方法或者finalize()方法已经被执行过，则在进行第二次标记后，被回收；
如果对象重写了finalize()方法，则可能会执行，如果此时该对象被重新引用，则第二次标记时会被移除，即可以逃出回收。	
finalize()方法不推荐使用，虽然可以用作关闭外部资源 但是最好用try-finally 因为finalize()不一定会执行

方法区的垃圾回收
	永久代的垃圾收集效率很低 不是所有虚拟机都回收方法区。
	目的：废弃常量和无用的类
		废弃常量：与废弃普通的对象一样 如果其他地方没有它的引用则回收
		废弃无用类：该类的所有实例都已被回收且加载该类的类加载器已经被回收且该类对应的Class对象没有其他地方引用(无法在任何地方通过反射访问该类的方法)，则该无用类可以回收。即：类卸载
		
######################################################################################################################################################################################
【垃圾回收算法】
标记清除算法Mark-Sweep
		标记+清除
		首先标记处所有要清除的对象，在标记完成后统一进行回收。
		缺点：
			标记和清除两个过程的效率都不高
			标记清除之后产生大量不连续的内存碎片 后续分配可能导致无法分配大内存而不得不提前触发另一次垃圾回收
			
复制算法Copying
		将内存分为两大块，每次只使用其中的一块，这一块内存用完了就把还存活的对象复制到另一块内存上，然后清除原先这块内存。
		每次相当于只对整个半区进行内存回收，也不用考虑内存碎片的问题。实现简单，效率也高，但是需要更大的内存。
		
		回收新生代采用复制算法，但是不是按1:1,而是划分成一块较大的Eden和两块较小的Survivor空间(From Survivor、To Survivor)。
		每次只是用Eden和一个Survivor。每次回收时将Eden和Survivor中存活的对象一次性复制到另一个Survivor，然后清除Eden和原先的Survivor。
		HotSpot默认Eden和Survivor的比例是8:1，即每次新生代中可用内存空间为整个新生代容量的90%
		如果Survivor不够，还需要额外的分配担保，即老年代
		默认新生代老年代的比例1:2
		
		缺点：如果新生代中的对象的存活率较高，则需要进行大量的复制操作，效率会变低。一般只有少部分对象存活率高。
		
标记整理算法Mark-Compact
		标记要清除的对象 将存活的对象向一端移动，然后直接清理掉端边界之外的内存
		
分代收集算法Generational Collection
		在新生代中，每次垃圾收集都发现有大量对象失效，则使用复制算法；
		在老年代中，因为对象的存活率高，没有额外的空间对它进行担保，就必须使用标记-清理或者标记-整理算法
		
#######################################################################################################################################################################################
【如何选择GC Roots】
GC Roots枚举根节点依靠OopMap的数据结构
		在类加载完成后就会把对象内什么偏移量上是什么类型的数据计算出来，JIT编译中也会在特定位置记录栈和寄存器中哪些位置是引用。
【如何进入GC】
安全点safepoint		
		GC必须停止所有java执行线程，因为可达性分析出的结果和在最终回收的中间可能会有对象引用关系的变化。这就是为什么jav应用隔段时间就会停顿一下。
		java执行线程不是任何情况都能停止的，因为有些操作会影响OopMap的变化。一般选取方法调用、循环跳转、异常跳转等长时间执行的指令作为安全点。
安全区域saferegion
		如果gc时 某个java执行线程刚好挂起了 则这个线程无法收到jvm的中断请求。
		
#######################################################################################################################################################################################
【垃圾回收器】
1.Serial收集器 (新生代收集器)	串行 复制算法
		单线程，只会使用一个GC线程，并且GC时会把其他所有工作线程暂停
		默认的Client模式下的新生代收集器
		
2.ParNew收集器 (新生代收集器)	并行 复制算法
		多线程。Serial收集器的多线程版
		许多Server模式下的虚拟机的首选新生代收集器
		
3.Parallel Scavenge收集器 (新生代收集器)  并行(吞吐量优先，自适应) 复制算法
4.Serial Old收集器 (老年代收集器) 串行 标记-整理算法
		Serial收集器的老年代版本
		默认的Client模式下的老年代收集器
5.Parallel Old收集器 (老年代收集器) 并行 标记-整理算法
		Parallel Scavenge收集器的老年代版本
		
6.CMS收集器 (老年代收集器)	并发 标记-清除算法	
		Concurrent Mark Sweep
		以获取最短停顿时间为目标 gc时用户线程不暂停 是并发的
		步骤：初始标记、并发标记、重新标记、并发清除
7.G1收集器
		新生代+老年代收集器
		并行+并发
		整体基于标记-整理 局部基于复制算法
		可预测的垃圾回收停顿
		步骤：初始标记、并发标记、最终标记、筛选回收
		
#######################################################################################################################################################################################
对象优先在Eden分配
		Eden区不够分配时，触发一次新生代GC(Minor GC)
大对象直接进入老年代
长期存活的对象进入老年代
		对象年龄：对象在Eden区经过第一次Minor GC仍然存活并且能被Survivor容纳，则会被移动到Survivor区，对象年龄设为1
				  Survivor区中的对象每熬过一次Minor GC 年龄加一
				  默认一般年龄到15岁 或者同年龄的所有对象占了Survivor的一半空间 就会到老年代中。
空间分配担保
		Minor GC之前会检查老年代空间是否大于新生代对象总空间 如果大于 则Minor GC是安全的。否则可能是有风险的或者需要升级为进行一次Full GC
		Full GC：或Major GC 老年代GC 速度比Minor GC慢的多 一般会伴随至少一次的Minor GC
		