Java内存模型 JMM
	类似于操作系统中多核处理器直接与各自的高速缓存直接操作，多个高速缓存最终通过一些缓存一致性协议来保证主内存的数据一致性

	目标：定义程序中各个变量的访问规则，即虚拟机中将变量存储到内存和从内存中取出变量
		  这个变量是指存在竞争的变量 即实例字段，静态变量，构成数组对象的元素
		  
	Java内存也分为主内存和工作内存 每个线程有自己的工作内存，工作内存中保存了该线程使用到的变量的主内存副本拷贝
	线程只能读写自己的工作线程的变量，无法直接访问其他线程的变量，线程间变量的传递需要通过主内存
	
	
	内存间的交互操作
		本质上还是单子操作+锁的方式
		
	volatile
		保证变量对所有线程的可见性(当一个线程修改了这个变量的值，其他线程能够立即得知(新值立即同步到主内存，每次读取也是立即从主内存刷新))
		volatile不是并发安全的，只能保证可见性
		可以禁用指令重排序优化
		
		多个变量需要有序赋值但是变量之间没有依赖关系时，对于最后的一些标识性变量(如标识是否初始化完成)可以分析后考虑使用volatile，避免由于指令重排序导致的标识变量被提前赋值
		
		volatile是轻量级的同步方法 如果volatile满足语义需要就可以使用它 否则可以使用锁等技术
		
	long、double的特殊规则
		jvm允许对于64位的没有被volatile修饰的变脸的读写操作划分为两次32位的操作，即long、double的非原子性协定。但是一般商用虚拟机还是把64位数据的读写操作以原子操作方式执行
		
		
	-----------------
	原子性
		原子变量操作 read load assign use store write
		lock unlock
		monitorenter monitorexit 对应synchronized
		
	可见性
		变量的读写依赖主内存。新值同步回主内存，读取时从主内存刷新变量值。以此来保证可见性，但是并发不安全
		volatile立即可见 但是并发依旧不安全
		synchronized保证在unlock之前会把变量同步到主内存中
		final保证一旦初始化完成(初始化要避免this逃逸)，就可以被其他线程访问到，无需同步
		
	有序性
		线程内表现为串行的语义
		实际会受到指令重排序和工作内存与主内存同步延迟的影响
		volatile和synchronized能保证一定的顺序性
		
	------------------------
	先行发生原则
		默认能够保证先行发生原则的规则
			程序次序规则：单线程内的代码顺序
			管程锁定规则：unlock操作先行发生于后面对同一个锁的lock操作
			volatile变量规则：volatile变量的写操作先行发生于后面对这个变量的读操作
			线程启动规则：Thread对象的start方法先行发生于此线程的每一个动作
			线程终止规则：线程中所有的操作都先行发生于对此线程的终止检测，可以通过Thread.join()方法结束、Thread.isAlive()方法检测到线程已终止执行
			线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupt()方法检测是否有中断发生
			对象终结规则: 一个对象的初始化完成(构造函数执行结束)先行发生于它的finalize()方法的开始
			传递性：a先行发生于b b先行发生于c 则a先行发生于c
			
		如果不满足，就没有顺序保障，就是线程不安全的，虚拟机也可以对他们进行重排序。先行发生于时间上的先后顺序也不是一个概念
		衡量并发安全的原则就是先行发生原则
		
		