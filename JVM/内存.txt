【虚拟机运行时数据区域】

	程序计数器	【线程私有】
		当前线程所执行的字节码的行号指示器。
		每个线程都有一个独立的程序计数器 保存当前线程执行到的指令位置 在线程切换回来之后能够继续执行
		此区域是唯一的没有规定OOM情况的区域
		
	虚拟机栈	【线程私有】
		生命周期与线程相同 是描述Java方法执行的内存模型		-Xss
		每个方法在执行时都会创建栈帧(Stack Frame)来存储局部变量表、操作数栈、动态链接、方法出口等信息
		放个方法从调用直至执行完成的过程 就是栈帧入栈到出栈的过程
		
		局部变量表：存储基本数据类型、
					对象引用(reference类型 一个指向对象起始地址的引用指针或者指向一个代表对象的句柄或者其他与此对象相关的位置)、
					returnAddress类型(指向了一条字节码指令的地址)
					
					编译器分配内存 方法运行期间不会改变局部变量表的大小
					局部变量空间slot是具体存储数据的结构
		
	本地方法栈	【线程私有】
		执行Native方法。类似栈 只是用于执行的方法不一样。有的虚拟机把栈和本地方法栈合二为一 如HotSpot。 -Xoss
		
	堆			【线程共享】
		虚拟机启动时创建 
		一般是内存占用最大的一块区域，也是垃圾收集器管理的主要区域(也叫GC堆)
		存放对象实例 几乎所有的对象实例及所有数组都在此分配内存(除了栈上分配、标量替换等优化技术会导致对象可能不在此处分配内存)，一般在新生代的Eden区上
		
		分类
			新生代
			老年代
			
		其中可能还会分配出多个线程私有的缓冲区TLAB(解决多线程分配内存的并发问题) -XX:+/-UseTLAB
		
		-Xmx -Xms
		
		部分对象可以继续引用直接内存中的地址 比如DirectByteBuffer
		
	本地方法区	【线程共享】   PermSize MaxPermSize
		存储被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等。是堆的一个逻辑部分。
		也称作永久代 java8之后叫元数据区
		
		运行时常量池是方法区的一部分
			Class文件中除了类的版本 字段 方法 接口等描述信息外，还有常量池(Constant Pool Table)，用于存放编译器生成的各种字面量和符号引用
			String.intern() 动态的把新的常量放到运行时常量池中
	
	
	
StackOverflowError	
	线程请求的栈深度超出了虚拟机允许的深度(深度可以动态扩展)
	
OutOfMemoryError
	1.动态扩展栈深度时无法申请到足够的内存
	2.堆内存无法继续分配且也无法再扩展时  (-Xmx -Xms 设为一样可以避免堆自动扩展)
	3.方法区无法继续分配且也无法再扩展时
	4.直接内存不够时 
	

####################################################################################################################################################################
【对象的创建】 TODO
	new  普通对象

	1.	检查new指令的参数是否能在常量池中找到对应的类的符号引用，并检查这个符号引用的类是否已被加载、解析和初始化过。
		如果没有，先执行类加载过程。
	2.	分配内存，对象所需的内存在类加载完成之后便可以完全确定。
		分配方式：
			指针碰撞：	堆内存是连续的，将指针向空闲空间移动一段和对象大小相等的距离
			空闲列表：	不连续 不规整。需要维护一个列表记录哪些块是可用的。分配的时候从列表中选择一个足够大的空间划分给对象。
		分配内存的并发问题处理：
			a.同步(CAS+失败重试)
			b.本地线程分配缓冲TLAB
	3.	初始化为零值(不包括对象头)
	4.	设置对象头
			哪个类的实例 元数据信息 对象的哈希值 gc分代年龄 是否启用偏向锁等
	5. <init>	
----------------------------------
对象的内存布局(数据结构)
	对象头Header
		对象的运行时数据(Mark Word)
			hashcode gc分代年龄 锁状态标志 锁 偏向线程id 偏向时间戳等
		类型指针(指向对象的类元数据的指针)
			非必须的。虚拟机通过这个指针确定对象是哪个类的实例。会指到方法区
		
	实例数据Instance Data
		各个类型的字段的内容，包括从父类继承来的。
		顺序由分配策略参数和类中字段定义的顺序有关
	
	对齐填充Padding
		虚拟机要求对象的大小必须是8字节的整数倍。对象头是8字节的倍数，当对象实例部分没有对齐时，就需要对齐填充来补全
-----------------------------------		
对象的访问定位
	1.使用句柄
		堆中划分出一块内存来作为句柄池，栈中的reference中存储的就是对象的句柄地址。句柄中包含了对象的实例数据与类型数据各自的地址信息。
		移动对象(垃圾回收过程中常见)只会改变句柄中的实例数据指针 reference本身不需要修改
	
	2.直接指针
		栈中的reference存储的是对象地址(堆中的对象头中要包含类型指针)
		速度更快 节省了一次指针定位的事件开销